import { AllVals, Float, Vec2, Vec3, Vec4 } from "../exprtypes";
import { Operator as Op, PrimitiveFloat } from "./expr";
export declare class TernaryExpr<T extends AllVals, U extends AllVals> extends Op<T> {
    success: T;
    failure: U;
    constructor(floats: Float[] | null, success: T, failure: U, not: boolean);
}
export declare function ternary<T extends Float, U extends Float>(floats: (Float | number)[] | Float | number | null, success: T, failure: U, not?: boolean): TernaryExpr<T, U>;
export declare function ternary<T extends Float>(floats: (Float | number)[] | Float | number | null, success: T, failure: number, not?: boolean): TernaryExpr<T, PrimitiveFloat>;
export declare function ternary<U extends Float>(floats: (Float | number)[] | Float | number | null, success: number, failure: U, not?: boolean): TernaryExpr<PrimitiveFloat, U>;
export declare function ternary(floats: (Float | number)[] | Float | number | null, success: number, failure: number, not?: boolean): TernaryExpr<PrimitiveFloat, PrimitiveFloat>;
export declare function ternary<T extends Vec2, U extends Vec2>(floats: (Float | number)[] | Float | number | null, success: T, failure: U, not?: boolean): TernaryExpr<T, U>;
export declare function ternary<T extends Vec3, U extends Vec3>(floats: (Float | number)[] | Float | number | null, success: T, failure: U, not?: boolean): TernaryExpr<T, U>;
export declare function ternary<T extends Vec4, U extends Vec4>(floats: (Float | number)[] | Float | number | null, success: T, failure: U, not?: boolean): TernaryExpr<T, U>;
