import { UniformLocs, EffectLoop, EffectLike, Generable } from "../mergepass";
import { AllVals, Float, TypeString } from "../exprtypes";
interface UniformTypeMap {
    [name: string]: TypeString;
}
/** info needed to generate proper declarations */
export interface BuildInfo {
    uniformTypes: UniformTypeMap;
    externalFuncs: Set<string>;
    exprs: Expr[];
    needs: Needs;
}
export interface UniformValChangeMap {
    [name: string]: {
        val: Primitive;
        changed: boolean;
    };
}
export interface DefaultNameMap {
    [name: string]: string;
}
export interface Needs {
    neighborSample: boolean;
    centerSample: boolean;
    sceneBuffer: boolean;
    timeUniform: boolean;
    mouseUniform: boolean;
    passCount: boolean;
    extraBuffers: Set<number>;
}
export interface SourceLists {
    sections: string[];
    values: AllVals[];
}
interface Parseable {
    parse: (buildInfo: BuildInfo, defaultName: string, enc: Expr | undefined) => string;
    /** returns the GLSL type as a string */
    typeString(): TypeString;
    brandExprWithRegion(space: Float[] | Float): Parseable;
}
export interface Applicable {
    /**
     * directly sets a uniform in a program; user should use [[setUniform]]
     * instead
     */
    applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
}
export declare abstract class Expr implements Parseable, EffectLike {
    /**
     * increments for each expression created; used to uniquely id each expression
     */
    static count: number;
    readonly id: string;
    readonly needs: Needs;
    readonly defaultNames: string[];
    readonly uniformValChangeMap: UniformValChangeMap;
    readonly defaultNameMap: DefaultNameMap;
    externalFuncs: string[];
    sourceLists: SourceLists;
    sourceCode: string;
    funcIndex: number;
    regionBranded: boolean;
    constructor(sourceLists: SourceLists, defaultNames: string[]);
    applyUniforms(gl: WebGL2RenderingContext, uniformLocs: UniformLocs): void;
    getSampleNum(mult?: number): number;
    /**
     * set a uniform by name directly
     * @param name uniform name in the source code
     * @param newVal value to set the uniform to
     */
    setUniform(name: string, newVal: AllVals | number): void;
    /**
     * parses this expression into a string, adding info as it recurses into
     * nested expressions
     */
    parse(buildInfo: BuildInfo): string;
    abstract typeString(): TypeString;
    addFuncs(funcs: string[]): this;
    brandExprWithChannel(funcIndex: number, samplerNum?: number): this;
    brandExprWithRegion(space: Float[] | Float): this;
}
/** create a custom float function (use with [[tag]]) */
export declare function cfloat(sourceLists: SourceLists, externalFuncs?: string[]): ExprFloat;
/** create a custom vec2 function (use with [[tag]]) */
export declare function cvec2(sourceLists: SourceLists, externalFuncs?: string[]): ExprVec2;
/** create a custom vec3 function (use with [[tag]]) */
export declare function cvec3(sourceLists: SourceLists, externalFuncs?: string[]): ExprVec3;
/** create a custom vec4 function (use with [[tag]]) */
export declare function cvec4(sourceLists: SourceLists, externalFuncs?: string[]): ExprVec4;
export declare class Mutable<T extends Primitive> implements Parseable, Applicable, EffectLike {
    primitive: T;
    name: string | undefined;
    constructor(primitive: T, name?: string);
    parse(buildInfo: BuildInfo, defaultName: string, enc: Expr | undefined): string;
    applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
    typeString(): TypeString;
    getSampleNum(): number;
    brandExprWithRegion(space: Float[] | Float): this;
}
export declare function mut<T extends Primitive>(val: T, name?: string): Mutable<T>;
export declare function mut(val: number, name?: string): Mutable<PrimitiveFloat>;
export declare abstract class Primitive implements Parseable, Applicable, EffectLike {
    abstract toString(): string;
    abstract typeString(): TypeString;
    abstract applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
    parse(): string;
    getSampleNum(): number;
    brandExprWithRegion(space: Float[] | Float): this;
}
export declare class PrimitiveFloat extends Primitive {
    value: number;
    constructor(num: number);
    toString(): string;
    typeString(): TypeString;
    applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
}
export declare abstract class PrimitiveVec extends Primitive {
    values: number[];
    constructor(comps: number[]);
    typeString(): TypeString;
    toString(): string;
}
export declare class PrimitiveVec2 extends PrimitiveVec {
    applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
}
export declare class PrimitiveVec3 extends PrimitiveVec {
    applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
}
export declare class PrimitiveVec4 extends PrimitiveVec {
    applyUniform(gl: WebGL2RenderingContext, loc: WebGLUniformLocation): void;
}
export declare abstract class BasicVec extends Expr {
    values: Float[];
    defaultNames: string[];
    constructor(sourceLists: SourceLists, defaultNames: string[]);
    typeString(): TypeString;
    /** sets a component of the vector */
    setComp(index: number, primitive: PrimitiveFloat | number): void;
}
export declare class BasicVec2 extends BasicVec {
    private bvec2;
}
export declare class BasicVec3 extends BasicVec {
    private bvec3;
}
export declare class BasicVec4 extends BasicVec {
    private bvec4;
}
export declare abstract class ExprVec extends Expr {
    values: Float[];
    defaultNames: string[];
    constructor(sourceLists: SourceLists, defaultNames: string[]);
}
export declare class BasicFloat extends Expr {
    private float;
    constructor(sourceLists: SourceLists, defaultNames: string[]);
    setVal(primitive: PrimitiveFloat | number): void;
    typeString(): TypeString;
}
export declare class ExprFloat extends Expr {
    private float;
    constructor(sourceLists: SourceLists, defaultNames: string[]);
    setVal(primitive: PrimitiveFloat | number): void;
    typeString(): TypeString;
}
export declare function float(value: Float | number): BasicFloat;
export declare class ExprVec2 extends ExprVec {
    private vec2;
    typeString(): TypeString;
}
export declare class ExprVec3 extends ExprVec {
    private vec3;
    typeString(): TypeString;
}
export declare class ExprVec4 extends ExprVec implements Generable {
    private vec4;
    repeat(num: number): EffectLoop;
    genPrograms(gl: WebGL2RenderingContext, vShader: WebGLShader, uniformLocs: UniformLocs, shaders: WebGLShader[]): import("../webglprogramloop").WebGLProgramLoop;
    typeString(): TypeString;
}
export declare class WrappedExpr<T extends AllVals> implements Parseable {
    expr: T;
    constructor(expr: T);
    typeString(): TypeString;
    parse(buildInfo: BuildInfo, defaultName: string, enc?: Expr): string;
    getSampleNum(): number;
    brandExprWithRegion(space: Float[] | Float): Parseable;
}
export declare class Operator<T extends AllVals> extends Expr {
    ret: T;
    constructor(ret: T, sourceLists: SourceLists, defaultNames: string[]);
    typeString(): TypeString;
}
/** creates a primitive float */
export declare function pfloat(num: number): PrimitiveFloat;
/** @ignore */
export declare function wrapInValue(num: number): PrimitiveFloat;
export declare function wrapInValue<T extends AllVals>(num: T | number): T;
export declare function wrapInValue<T extends AllVals>(num: T | number | undefined): T | PrimitiveFloat | undefined;
/**
 * takes a template strings array and converts it to a source list; very useful
 * for [[cfloat]], [[cvec2]], [[cvec3]] and [[cvec4]]
 */
export declare function tag(strings: TemplateStringsArray, ...values: AllVals[]): SourceLists;
export {};
