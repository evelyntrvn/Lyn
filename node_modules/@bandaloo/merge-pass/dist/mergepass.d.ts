import { ExprVec4, Needs } from "./exprs/expr";
import { Float, Vec4 } from "./exprtypes";
import { WebGLProgramLoop } from "./webglprogramloop";
/** repetitions and callback for loop */
export interface LoopInfo {
    /** amount of times to repeat the loop */
    num: number;
    /** the channel buffer to target */
    target?: number;
    /** optional callback for loop */
    func?: (arg0: number) => void;
}
/**
 * classes that implement this can return how many times they sample the
 * original scene
 */
export interface EffectLike {
    /**
     * gets the amount of times an effect will need to sample the original scene
     * @param mult multiplier of the loop
     */
    getSampleNum(mult: number): number;
}
/**
 * a class implementing this interface can be compiled into a
 * [[WebGLProgramLoop]] which can contain nested loops
 */
export interface Generable {
    /** recursively generate programs out of this effect and all nested effects */
    genPrograms(gl: WebGL2RenderingContext, vShader: WebGLShader, uniformLocs: UniformLocs, shaders: WebGLShader[]): WebGLProgramLoop;
}
interface ProgramMap {
    [name: string]: WebGLProgramLoop;
}
interface UnprocessedEffectMap {
    [name: string]: (Vec4 | EffectLoop)[];
}
interface EffectMap {
    [name: string]: EffectElement[];
}
export declare class EffectDictionary {
    effectMap: EffectMap;
    constructor(effectMap: UnprocessedEffectMap);
    toProgramMap(gl: WebGL2RenderingContext, vShader: WebGLShader, uniformLocs: UniformLocs, fShaders: WebGLShader[]): {
        programMap: ProgramMap;
        needs: Needs;
    };
}
/** effect loop, which can loop over other effects or effect loops */
export declare class EffectLoop implements EffectLike, Generable {
    effects: EffectElement[];
    loopInfo: LoopInfo;
    constructor(effects: (Vec4 | EffectLoop)[], loopInfo: LoopInfo);
    /** @ignore */
    getSampleNum(mult?: number, sliceStart?: number, sliceEnd?: number): number;
    /**
     * @ignore
     * places effects into loops broken up by sampling effects
     */
    regroup(): EffectElement[];
    genPrograms(gl: WebGL2RenderingContext, vShader: WebGLShader, uniformLocs: UniformLocs, shaders: WebGLShader[]): WebGLProgramLoop;
    /**
     * changes the render target of an effect loop (-1 targest the scene texture;
     * this is used internally)
     */
    target(num: number): this;
    /** @ignore */
    hasTargetSwitch(): boolean;
    /** @ignore */
    regionWrap(space: Float[] | Float, failure: Vec4, finalPath: boolean | undefined, not: boolean): this;
}
/** creates an effect loop */
export declare function loop(effects: (Vec4 | EffectLoop)[], rep?: number): EffectLoop;
/**
 * type denoting that expressions that return a vec4 or loops can be considered
 * "effects"
 */
declare type EffectElement = ExprVec4 | EffectLoop;
/**
 * map of names to uniform locations with a counter for how many times they have
 * been updated in the current loop
 */
export interface UniformLocs {
    [name: string]: {
        locs: WebGLUniformLocation[];
        counter: number;
    };
}
/** setting for min and max texture filtering modes */
declare type FilterMode = "linear" | "nearest";
/** setting for clamp */
declare type ClampMode = "clamp" | "wrap";
/** extra texture options for the merger */
interface MergerOptions {
    /** min filtering mode for the texture */
    minFilterMode?: FilterMode;
    /** max filtering mode for the texture */
    maxFilterMode?: FilterMode;
    /** how the edges of the texture should be handled */
    edgeMode?: ClampMode;
    /** textures or images to use as extra channels */
    channels?: (TexImageSource | WebGLTexture | null)[];
}
/** @ignore */
export interface TexInfo {
    front: TexWrapper;
    back: TexWrapper;
    scene: TexWrapper | undefined;
    bufTextures: TexWrapper[];
}
/** useful for debugging */
export interface TexWrapper {
    name: string;
    tex: WebGLTexture;
}
/** class that can merge effects */
export declare class Merger {
    /** the context to render to */
    readonly gl: WebGL2RenderingContext;
    /** the context to apply post-processing to */
    private source;
    tex: TexInfo;
    private framebuffer;
    private uniformLocs;
    private programMap;
    private programLoop;
    /** additional channels */
    private channels;
    private options;
    private vertexBuffer;
    private vShader;
    private fShaders;
    textureMode: boolean;
    /**
     * constructs the object that runs the effects
     * @param effects list of effects that define the final effect
     * @param source the source image or texture
     * @param gl the target rendering context
     * @param options additional options for the texture
     */
    constructor(effects: (Vec4 | EffectLoop)[] | EffectDictionary, source: TexImageSource | WebGLTexture, gl: WebGL2RenderingContext, options?: MergerOptions);
    /**
     * use the source and channels to draw effect to target context; mouse
     * position (as with all positions) are stored from the bottom left corner as
     * this is how texture data is stored
     * @param timeVal number to set the time uniform to (supply this if you plan to
     * use [[time]])
     * @param mouseX the x position of the mouse (supply this if you plan to use
     * [[mouse]] or [[nmouse]])
     * @param mouseY the y position of the mouse (supply this if you plan to use
     * [[mouse]] or [[nmouse]])
     */
    draw(timeVal?: number, mouseX?: number, mouseY?: number): void;
    /**
     * delete all resources created by construction of this [[Merger]]; use right before
     * intentionally losing a reference to this merger object. this is useful if you want
     * to construct another [[Merger]] to use new effects
     */
    delete(): void;
    /**
     * changes the current program loop
     * @param str key in the program map
     */
    changeProgram(str: string): void;
}
/** creates a texture given a context and options */
export declare function makeTexture(gl: WebGL2RenderingContext, options?: MergerOptions): WebGLTexture;
/** copies onto texture */
export declare function sendTexture(gl: WebGL2RenderingContext, src: TexImageSource | WebGLTexture | null): void;
export {};
