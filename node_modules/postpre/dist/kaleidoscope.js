"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.kaleidoscope = exports.Kaleidoscope = void 0;
const merge_pass_1 = require("@bandaloo/merge-pass");
class Kaleidoscope extends merge_pass_1.WrappedExpr {
    constructor(sides, scale) {
        const sidesFloat = merge_pass_1.float(sides);
        const scaleFloat = merge_pass_1.float(scale);
        const tpos = merge_pass_1.op(merge_pass_1.translate(merge_pass_1.pos(), merge_pass_1.vec2(-0.5, -0.5)), "/", scaleFloat);
        const angle = merge_pass_1.a2("atan", merge_pass_1.getcomp(tpos, "y"), merge_pass_1.getcomp(tpos, "x"));
        const b = merge_pass_1.op(2 * Math.PI, "*", merge_pass_1.op(1, "/", sidesFloat));
        const mangle = merge_pass_1.op(merge_pass_1.a1("floor", merge_pass_1.op(angle, "/", b)), "*", b);
        const a = merge_pass_1.op(angle, "-", mangle);
        const flip = merge_pass_1.op(b, "-", merge_pass_1.op(2, "*", a));
        const sign = merge_pass_1.a1("floor", merge_pass_1.op(merge_pass_1.a2("mod", merge_pass_1.op(mangle, "+", 0.1), merge_pass_1.op(b, "*", 2)), "/", b));
        const spos = merge_pass_1.translate(merge_pass_1.rotate(tpos, merge_pass_1.op(mangle, "-", merge_pass_1.op(flip, "*", sign))), merge_pass_1.vec2(0.5, 0.5));
        super(merge_pass_1.channel(-1, spos));
        this.sidesFloat = sidesFloat;
        this.scaleFloat = scaleFloat;
        this.sides = sides;
        this.scale = scale;
    }
    setSides(sides) {
        this.sidesFloat.setVal(merge_pass_1.wrapInValue(sides));
        this.sides = merge_pass_1.wrapInValue(sides);
    }
    setScale(scale) {
        this.scaleFloat.setVal(merge_pass_1.wrapInValue(scale));
        this.scale = merge_pass_1.wrapInValue(scale);
    }
}
exports.Kaleidoscope = Kaleidoscope;
function kaleidoscope(sides = merge_pass_1.mut(8), scale = merge_pass_1.mut(1)) {
    return new Kaleidoscope(merge_pass_1.wrapInValue(sides), merge_pass_1.wrapInValue(scale));
}
exports.kaleidoscope = kaleidoscope;
