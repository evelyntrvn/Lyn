"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.foggyrays = exports.FoggyRaysExpr = void 0;
const merge_pass_1 = require("@bandaloo/merge-pass");
class FoggyRaysExpr extends merge_pass_1.WrappedExpr {
    constructor(period, speed, throwDistance, numSamples, samplerNum, convertDepthColor) {
        const periodFloat = merge_pass_1.float(period);
        const speedFloat = merge_pass_1.float(speed);
        const throwDistanceFloat = merge_pass_1.float(throwDistance);
        const fog = merge_pass_1.op(merge_pass_1.op(merge_pass_1.simplex(merge_pass_1.op(merge_pass_1.op(merge_pass_1.pos(), "+", merge_pass_1.op(merge_pass_1.op(merge_pass_1.time(), "*", speedFloat), "/", periodFloat)), "*", merge_pass_1.op(merge_pass_1.resolution(), "/", merge_pass_1.op(periodFloat, "*", 2)))), "*", merge_pass_1.simplex(merge_pass_1.op(merge_pass_1.op(merge_pass_1.pos(), "+", merge_pass_1.op(merge_pass_1.op(merge_pass_1.time(), "*", speedFloat), "/", merge_pass_1.op(periodFloat, "*", -2))), "*", merge_pass_1.op(merge_pass_1.resolution(), "/", merge_pass_1.op(periodFloat, "*", 4))))), "*", 0.5);
        const expr = merge_pass_1.godrays({
            weight: 0.009,
            density: merge_pass_1.op(throwDistanceFloat, "+", merge_pass_1.op(fog, "*", 0.5)),
            convertDepth: convertDepthColor !== undefined
                ? { threshold: 0.01, newColor: convertDepthColor }
                : undefined,
            samplerNum: samplerNum,
            numSamples: numSamples,
        });
        super(expr);
        this.periodFloat = periodFloat;
        this.speedFloat = speedFloat;
        this.throwDistanceFloat = throwDistanceFloat;
        this.godraysExpr = expr;
        this.convertsDepth = convertDepthColor !== undefined;
        this.period = period;
        this.speed = speed;
        this.throwDistance = throwDistance;
    }
    setPeriod(period) {
        this.periodFloat.setVal(merge_pass_1.wrapInValue(period));
        this.period = merge_pass_1.wrapInValue(period);
    }
    setSpeed(speed) {
        this.speedFloat.setVal(merge_pass_1.wrapInValue(speed));
        this.speed = merge_pass_1.wrapInValue(speed);
    }
    setThrowDistance(throwDistance) {
        this.throwDistanceFloat.setVal(merge_pass_1.wrapInValue(throwDistance));
        this.throwDistance = merge_pass_1.wrapInValue(throwDistance);
    }
    setNewColor(newColor) {
        if (this.convertsDepth === undefined) {
            throw new Error("can only set new color if you are converting from a depth buffer");
        }
        this.godraysExpr.setNewColor(newColor);
    }
}
exports.FoggyRaysExpr = FoggyRaysExpr;
function foggyrays(period = merge_pass_1.mut(100), speed = merge_pass_1.mut(1), throwDistance = merge_pass_1.mut(0.3), numSamples = 100, samplerNum, convertDepthColor) {
    return new FoggyRaysExpr(merge_pass_1.wrapInValue(period), merge_pass_1.wrapInValue(speed), merge_pass_1.wrapInValue(throwDistance), numSamples, samplerNum, convertDepthColor);
}
exports.foggyrays = foggyrays;
