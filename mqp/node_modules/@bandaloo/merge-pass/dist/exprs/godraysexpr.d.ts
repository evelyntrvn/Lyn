import { Float, Vec2, Vec4 } from "../exprtypes";
import { ExprVec4, PrimitiveFloat, PrimitiveVec2, PrimitiveVec4 } from "./expr";
/** godrays expression */
export declare class GodRaysExpr extends ExprVec4 {
    col: Vec4;
    exposure: Float;
    decay: Float;
    density: Float;
    weight: Float;
    lightPos: Vec2;
    threshold?: Float;
    newColor?: Vec4;
    constructor(col?: Vec4, exposure?: Float, decay?: Float, density?: Float, weight?: Float, lightPos?: Vec2, samplerNum?: number, numSamples?: number, convertDepth?: {
        threshold: Float;
        newColor: Vec4;
    });
    /** sets the light color */
    setColor(color: PrimitiveVec4): void;
    /** sets the exposure */
    setExposure(exposure: PrimitiveFloat | number): void;
    /** sets the decay */
    setDecay(decay: PrimitiveFloat | number): void;
    /** sets the density */
    setDensity(density: PrimitiveFloat | number): void;
    /** sets the weight */
    setWeight(weight: PrimitiveFloat | number): void;
    /** sets the light position */
    setLightPos(lightPos: PrimitiveVec2): void;
    setThreshold(threshold: PrimitiveFloat | number): void;
    setNewColor(newColor: PrimitiveVec4): void;
}
/** options that define how the godrays will look */
interface GodraysOptions {
    /** color of the light */
    color?: Vec4;
    /** multiplies final output */
    exposure?: Float | number;
    /** how much to decrease light for each sample */
    decay?: Float | number;
    /** how close samples are together */
    density?: Float | number;
    /** multiplies the original background colors */
    weight?: Float | number;
    /** where the rays eminate from */
    lightPos?: Vec2;
    /**
     * number of samples; aka the quality (note that this cannot be changed at
     * runtime, as looping by a non-constant does not play nice with shaders)
     */
    numSamples?: number;
    /** where to sample from */
    samplerNum?: number;
    /** information for how to convert a depth buffer into an occlusion buffer */
    convertDepth?: {
        /** what depth is unoccluded (assumes `1 / distance` depth buffer) */
        threshold: Float | number;
        /** what the unoccluded color should be */
        newColor: Vec4;
    };
}
/**
 * create a godrays expression which requires an occlusion map; all values are
 * mutable by default
 * @param options object that defines godrays properties (has sane defaults)
 */
export declare function godrays(options?: GodraysOptions): GodRaysExpr;
export {};
