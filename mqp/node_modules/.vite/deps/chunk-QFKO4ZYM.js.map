{
  "version": 3,
  "sources": ["../../@bandaloo/merge-pass/dist/settings.js", "../../@bandaloo/merge-pass/dist/webglprogramloop.js", "../../@bandaloo/merge-pass/dist/glslfunctions.js", "../../@bandaloo/merge-pass/dist/utils.js", "../../@bandaloo/merge-pass/dist/exprs/expr.js", "../../@bandaloo/merge-pass/dist/codebuilder.js", "../../@bandaloo/merge-pass/dist/exprs/fragcolorexpr.js", "../../@bandaloo/merge-pass/dist/exprs/getcompexpr.js", "../../@bandaloo/merge-pass/dist/exprs/normfragcoordexpr.js", "../../@bandaloo/merge-pass/dist/exprs/opexpr.js", "../../@bandaloo/merge-pass/dist/exprs/ternaryexpr.js", "../../@bandaloo/merge-pass/dist/exprs/regiondecorator.js", "../../@bandaloo/merge-pass/dist/exprs/scenesampleexpr.js", "../../@bandaloo/merge-pass/dist/exprs/setcolorexpr.js", "../../@bandaloo/merge-pass/dist/mergepass.js", "../../@bandaloo/merge-pass/dist/exprtypes.js", "../../@bandaloo/merge-pass/dist/exprs/blurexpr.js", "../../@bandaloo/merge-pass/dist/exprs/vecexprs.js", "../../@bandaloo/merge-pass/dist/exprs/powerblur.js", "../../@bandaloo/merge-pass/dist/exprs/blur2dloop.js", "../../@bandaloo/merge-pass/dist/exprs/lenexpr.js", "../../@bandaloo/merge-pass/dist/exprs/normexpr.js", "../../@bandaloo/merge-pass/dist/exprs/fragcoordexpr.js", "../../@bandaloo/merge-pass/dist/exprs/normcenterfragcoordexpr.js", "../../@bandaloo/merge-pass/dist/exprs/brightnessexpr.js", "../../@bandaloo/merge-pass/dist/exprs/contrastexpr.js", "../../@bandaloo/merge-pass/dist/exprs/grainexpr.js", "../../@bandaloo/merge-pass/dist/exprs/changecompexpr.js", "../../@bandaloo/merge-pass/dist/exprs/rgbtohsvexpr.js", "../../@bandaloo/merge-pass/dist/exprs/hsvtorgbexpr.js", "../../@bandaloo/merge-pass/dist/exprs/timeexpr.js", "../../@bandaloo/merge-pass/dist/exprs/arity1.js", "../../@bandaloo/merge-pass/dist/exprs/arity2.js", "../../@bandaloo/merge-pass/dist/exprs/fxaaexpr.js", "../../@bandaloo/merge-pass/dist/exprs/channelsampleexpr.js", "../../@bandaloo/merge-pass/dist/exprs/gaussianexpr.js", "../../@bandaloo/merge-pass/dist/exprs/dofloop.js", "../../@bandaloo/merge-pass/dist/exprs/truedepthexpr.js", "../../@bandaloo/merge-pass/dist/exprs/godraysexpr.js", "../../@bandaloo/merge-pass/dist/exprs/depthtoocclusionexpr.js", "../../@bandaloo/merge-pass/dist/exprs/resolutionexpr.js", "../../@bandaloo/merge-pass/dist/exprs/mouseexpr.js", "../../@bandaloo/merge-pass/dist/exprs/rotateexpr.js", "../../@bandaloo/merge-pass/dist/exprs/translateexpr.js", "../../@bandaloo/merge-pass/dist/exprs/normmouseexpr.js", "../../@bandaloo/merge-pass/dist/exprs/perlinexpr.js", "../../@bandaloo/merge-pass/dist/exprs/simplexexpr.js", "../../@bandaloo/merge-pass/dist/exprs/motionblurloop.js", "../../@bandaloo/merge-pass/dist/exprs/randomexpr.js", "../../@bandaloo/merge-pass/dist/exprs/sobelexpr.js", "../../@bandaloo/merge-pass/dist/exprs/bloomloop.js", "../../@bandaloo/merge-pass/dist/exprs/monochromeexpr.js", "../../@bandaloo/merge-pass/dist/exprs/invertexpr.js", "../../@bandaloo/merge-pass/dist/exprs/edgeexpr.js", "../../@bandaloo/merge-pass/dist/exprs/edgecolorexpr.js", "../../@bandaloo/merge-pass/dist/index.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.settings = void 0;\nexports.settings = {\n    /**\n     * set to 1 if you want reasonable logging for debugging, such as the\n     * generated GLSL code and program tree. set to 100 if you want texture debug\n     * info (you probably don't want to do this, as it logs many lines every\n     * frame!)\n     */\n    verbosity: 0,\n    /** texture offset */\n    offset: 0,\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebGLProgramLoop = exports.WebGLProgramLeaf = exports.updateNeeds = void 0;\nconst settings_1 = require(\"./settings\");\n// update me on change to needs\nfunction updateNeeds(acc, curr) {\n    return {\n        neighborSample: acc.neighborSample || curr.neighborSample,\n        centerSample: acc.centerSample || curr.centerSample,\n        sceneBuffer: acc.sceneBuffer || curr.sceneBuffer,\n        timeUniform: acc.timeUniform || curr.timeUniform,\n        mouseUniform: acc.mouseUniform || curr.mouseUniform,\n        passCount: acc.passCount || curr.passCount,\n        extraBuffers: new Set([...acc.extraBuffers, ...curr.extraBuffers]),\n    };\n}\nexports.updateNeeds = updateNeeds;\nclass WebGLProgramLeaf {\n    constructor(program, totalNeeds, effects) {\n        this.program = program;\n        this.totalNeeds = totalNeeds;\n        this.effects = effects;\n    }\n}\nexports.WebGLProgramLeaf = WebGLProgramLeaf;\n/** @ignore */\nfunction getLoc(programElement, gl, name) {\n    gl.useProgram(programElement.program);\n    const loc = gl.getUniformLocation(programElement.program, name);\n    if (loc === null) {\n        throw new Error(\"could not get the \" + name + \" uniform location\");\n    }\n    return loc;\n}\n/** recursive data structure of compiled programs */\nclass WebGLProgramLoop {\n    constructor(programElement, loopInfo, gl) {\n        //effects: Expr[];\n        this.last = false;\n        this.counter = 0;\n        this.programElement = programElement;\n        this.loopInfo = loopInfo;\n        if (this.programElement instanceof WebGLProgramLeaf) {\n            if (gl === undefined) {\n                throw new Error(\"program element is a program but context is undefined\");\n            }\n            if (this.programElement.totalNeeds.timeUniform) {\n                this.timeLoc = getLoc(this.programElement, gl, \"uTime\");\n            }\n            if (this.programElement.totalNeeds.mouseUniform) {\n                this.mouseLoc = getLoc(this.programElement, gl, \"uMouse\");\n            }\n            if (this.programElement.totalNeeds.passCount) {\n                this.countLoc = getLoc(this.programElement, gl, \"uCount\");\n            }\n        }\n    }\n    /** get all needs from all programs */\n    getTotalNeeds() {\n        // go through needs of program loop\n        if (!(this.programElement instanceof WebGLProgramLeaf)) {\n            const allNeeds = [];\n            for (const p of this.programElement) {\n                allNeeds.push(p.getTotalNeeds());\n            }\n            return allNeeds.reduce(updateNeeds);\n        }\n        return this.programElement.totalNeeds;\n    }\n    /**\n     * recursively uses all programs in the loop, binding the appropriate\n     * textures and setting the appropriate uniforms; the user should only have\n     * to call [[draw]] on [[Merger]] and never this function directly\n     */\n    run(gl, tex, framebuffer, uniformLocs, last, defaultUniforms, outerLoop) {\n        let savedTexture;\n        if (this.loopInfo.target !== undefined &&\n            // if there is a target switch:\n            (outerLoop === null || outerLoop === void 0 ? void 0 : outerLoop.loopInfo.target) !== this.loopInfo.target) {\n            // swap out the back texture for the channel texture if this loop has\n            // an alternate render target\n            savedTexture = tex.back;\n            if (this.loopInfo.target !== -1) {\n                tex.back = tex.bufTextures[this.loopInfo.target];\n            }\n            else {\n                if (tex.scene === undefined) {\n                    throw new Error(\"tried to target -1 but scene texture was undefined\");\n                }\n                tex.back = tex.scene;\n            }\n            tex.bufTextures[this.loopInfo.target] = savedTexture;\n            if (settings_1.settings.verbosity > 99)\n                console.log(\"saved texture: \" + savedTexture.name);\n        }\n        // setup for program leaf\n        if (this.programElement instanceof WebGLProgramLeaf) {\n            // bind the scene texture if needed\n            if (this.programElement.totalNeeds.sceneBuffer) {\n                if (tex.scene === undefined) {\n                    throw new Error(\"needs scene buffer, but scene texture is somehow undefined\");\n                }\n                gl.activeTexture(gl.TEXTURE1 + settings_1.settings.offset);\n                if (this.loopInfo.target === -1) {\n                    gl.bindTexture(gl.TEXTURE_2D, savedTexture.tex);\n                }\n                else {\n                    gl.bindTexture(gl.TEXTURE_2D, tex.scene.tex);\n                }\n            }\n            // bind all extra channel textures if needed\n            for (const n of this.programElement.totalNeeds.extraBuffers) {\n                gl.activeTexture(gl.TEXTURE2 + n + settings_1.settings.offset);\n                gl.bindTexture(gl.TEXTURE_2D, tex.bufTextures[n].tex);\n            }\n            // use the current program\n            gl.useProgram(this.programElement.program);\n            // apply all uniforms\n            for (const effect of this.programElement.effects) {\n                effect.applyUniforms(gl, uniformLocs);\n            }\n            // set time uniform if needed\n            if (this.programElement.totalNeeds.timeUniform) {\n                if (this.timeLoc === undefined ||\n                    defaultUniforms.timeVal === undefined) {\n                    throw new Error(\"time or location is undefined\");\n                }\n                gl.uniform1f(this.timeLoc, defaultUniforms.timeVal);\n            }\n            // set mouse uniforms if needed\n            if (this.programElement.totalNeeds.mouseUniform) {\n                if (this.mouseLoc === undefined ||\n                    defaultUniforms.mouseX === undefined ||\n                    defaultUniforms.mouseY === undefined) {\n                    throw new Error(\"mouse uniform or location is undefined\");\n                }\n                gl.uniform2f(this.mouseLoc, defaultUniforms.mouseX, defaultUniforms.mouseY);\n            }\n            // set count uniform if needed\n            if (this.programElement.totalNeeds.passCount && outerLoop !== undefined) {\n                if (this.countLoc === undefined) {\n                    throw new Error(\"count location is undefined\");\n                }\n                if (outerLoop !== undefined) {\n                    gl.uniform1i(this.countLoc, outerLoop.counter);\n                }\n                this.counter++;\n                const mod = outerLoop === undefined ? 1 : outerLoop.loopInfo.num;\n                this.counter %= mod;\n            }\n        }\n        for (let i = 0; i < this.loopInfo.num; i++) {\n            const newLast = i === this.loopInfo.num - 1;\n            if (this.programElement instanceof WebGLProgramLeaf) {\n                if (newLast && last && this.last) {\n                    // we are on the final pass of the final loop, so draw screen by\n                    // setting to the default framebuffer\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                }\n                else {\n                    // we have to bounce between two textures\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n                    // use the framebuffer to write to front texture\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex.front.tex, 0);\n                }\n                // allows us to read from `texBack`\n                // default sampler is 0, so `uSampler` uniform will always sample from texture 0\n                gl.activeTexture(gl.TEXTURE0 + settings_1.settings.offset);\n                gl.bindTexture(gl.TEXTURE_2D, tex.back.tex);\n                // use our last program as the draw program\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n                if (settings_1.settings.verbosity > 99) {\n                    console.log(\"intermediate back\", tex.back.name);\n                    console.log(\"intermediate front\", tex.front.name);\n                }\n                // swap back and front\n                [tex.back, tex.front] = [tex.front, tex.back];\n                // deactivate and unbind all the channel textures needed\n                for (const n of this.programElement.totalNeeds.extraBuffers) {\n                    gl.activeTexture(gl.TEXTURE2 + n + settings_1.settings.offset);\n                    gl.bindTexture(gl.TEXTURE_2D, null);\n                }\n                gl.activeTexture(gl.TEXTURE1 + settings_1.settings.offset);\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            }\n            else {\n                if (this.loopInfo.func !== undefined) {\n                    this.loopInfo.func(i);\n                }\n                for (const p of this.programElement) {\n                    p.run(gl, tex, framebuffer, uniformLocs, newLast, defaultUniforms, this // this is now the outer loop\n                    );\n                }\n            }\n        }\n        // swap the textures back if we were temporarily using a channel texture\n        if (savedTexture !== undefined) {\n            const target = this.loopInfo.target;\n            if (settings_1.settings.verbosity > 99) {\n                console.log(\"pre final back\", tex.back.name);\n                console.log(\"pre final front\", tex.front.name);\n            }\n            // back texture is really the front texture because it was just swapped\n            if (this.loopInfo.target !== -1) {\n                tex.bufTextures[target] = tex.back;\n            }\n            else {\n                if (tex.scene === undefined) {\n                    throw new Error(\"tried to replace -1 but scene texture was undefined\");\n                }\n                tex.scene = tex.back;\n            }\n            tex.back = savedTexture;\n            if (settings_1.settings.verbosity > 99) {\n                console.log(\"post final back\", tex.back.name);\n                console.log(\"post final front\", tex.front.name);\n                console.log(\"channel texture\", tex.bufTextures[target].name);\n            }\n        }\n    }\n    delete(gl) {\n        if (this.programElement instanceof WebGLProgramLeaf) {\n            gl.deleteProgram(this.programElement.program);\n        }\n        else {\n            for (const p of this.programElement) {\n                p.delete(gl);\n            }\n        }\n    }\n}\nexports.WebGLProgramLoop = WebGLProgramLoop;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.glslFuncs = void 0;\n// adapted from The Book of Shaders\n/** glsl source code for external functions */\nexports.glslFuncs = {\n    // TODO bad to calculate single pixel width every time; maybe it can be a need\n    texture2D_region: `vec4 texture2D_region(\n  float r_x_min,\n  float r_y_min,\n  float r_x_max,\n  float r_y_max,\n  sampler2D sampler,\n  vec2 uv\n) {\n  vec2 d = vec2(1., 1.) / uResolution; // pixel width\n  return texture2D(sampler, clamp(uv, vec2(r_x_min + d.x, r_y_min + d.x), vec2(r_x_max - d.y, r_y_max - d.y)));\n}`,\n    // TODO replace with a better one\n    // adapted from The Book of Shaders\n    random: `float random(vec2 st) {\n  return fract(sin(dot(st.xy / 99., vec2(12.9898, 78.233))) * 43758.5453123);\n}`,\n    // adapted from The Book of Shaders\n    random2: `vec2 random2(vec2 st) {\n  st = vec2(dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)));\n  return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}`,\n    rotate2d: `vec2 rotate2d(vec2 v, float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * v;\n}`,\n    // adapted from The Book of Shaders\n    hsv2rgb: `vec4 hsv2rgb(vec4 co){\n  vec3 c = co.xyz;\n  vec3 rgb = clamp(abs(mod(\n    c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  vec3 hsv = c.z * mix(vec3(1.0), rgb, c.y);\n  return vec4(hsv.x, hsv.y, hsv.z, co.a);\n}`,\n    // adapted from The Book of Shaders\n    rgb2hsv: `vec4 rgb2hsv(vec4 co){\n  vec3 c = co.rgb;\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec4(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n              d / (q.x + e),\n              q.x, co.a);\n}`,\n    // all gaussian blurs adapted from:\n    // https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/5.glsl\n    gauss5: `vec4 gauss5(vec2 dir) {\n  vec2 uv = gl_FragCoord.xy / uResolution;\n  vec4 col = vec4(0.0);\n  vec2 off1 = vec2(1.3333333333333333) * dir;\n  col += texture2D(uSampler, uv) * 0.29411764705882354;\n  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.35294117647058826;\n  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.35294117647058826;\n  return col;\n}`,\n    gauss9: `vec4 gauss9(vec2 dir) {\n  vec2 uv = gl_FragCoord.xy / uResolution;\n  vec4 col = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * dir;\n  vec2 off2 = vec2(3.2307692308) * dir;\n  col += texture2D(uSampler, uv) * 0.2270270270;\n  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.3162162162;\n  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.3162162162;\n  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.0702702703;\n  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.0702702703;\n  return col;\n}`,\n    gauss13: `vec4 gauss13(vec2 dir) {\n  vec2 uv = gl_FragCoord.xy / uResolution;\n  vec4 col = vec4(0.0);\n  vec2 off1 = vec2(1.411764705882353) * dir;\n  vec2 off2 = vec2(3.2941176470588234) * dir;\n  vec2 off3 = vec2(5.176470588235294) * dir;\n  col += texture2D(uSampler, uv) * 0.1964825501511404;\n  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.2969069646728344;\n  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.2969069646728344;\n  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.09447039785044732;\n  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.09447039785044732;\n  col += texture2D(uSampler, uv + (off3 / uResolution)) * 0.010381362401148057;\n  col += texture2D(uSampler, uv - (off3 / uResolution)) * 0.010381362401148057;\n  return col;\n}`,\n    contrast: `vec4 contrast(float val, vec4 col) {\n  col.rgb /= col.a;\n  col.rgb = ((col.rgb - 0.5) * val) + 0.5;\n  col.rgb *= col.a;\n  return col;\n}`,\n    brightness: `vec4 brightness(float val, vec4 col) {\n  col.rgb /= col.a;\n  col.rgb += val;\n  col.rgb *= col.a;\n  return col;\n}`,\n    // adapted from https://www.shadertoy.com/view/ls3GWS which was adapted from\n    // http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n    // original algorithm created by Timothy Lottes\n    fxaa: `vec4 fxaa() {\n  float FXAA_SPAN_MAX = 8.0;\n  float FXAA_REDUCE_MUL = 1.0 / FXAA_SPAN_MAX;\n  float FXAA_REDUCE_MIN = 1.0 / 128.0;\n  float FXAA_SUBPIX_SHIFT = 1.0 / 4.0;\n\n  vec2 rcpFrame = 1. / uResolution.xy;\n  vec2 t_uv = gl_FragCoord.xy / uResolution.xy; \n  vec4 uv = vec4(t_uv, t_uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n  vec3 rgbNW = texture2D(uSampler, uv.zw).xyz;\n  vec3 rgbNE = texture2D(uSampler, uv.zw + vec2(1,0) * rcpFrame.xy).xyz;\n  vec3 rgbSW = texture2D(uSampler, uv.zw + vec2(0,1) * rcpFrame.xy).xyz;\n  vec3 rgbSE = texture2D(uSampler, uv.zw + vec2(1,1) * rcpFrame.xy).xyz;\n  vec4 rgbMfull = texture2D(uSampler, uv.xy);\n  vec3 rgbM = rgbMfull.xyz;\n  float alpha = rgbMfull.a;\n\n  vec3 luma = vec3(0.299, 0.587, 0.114);\n  float lumaNW = dot(rgbNW, luma);\n  float lumaNE = dot(rgbNE, luma);\n  float lumaSW = dot(rgbSW, luma);\n  float lumaSE = dot(rgbSE, luma);\n  float lumaM = dot(rgbM,  luma);\n\n  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n  vec2 dir;\n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n  float dirReduce = max(\n    (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n  float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n    max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n    dir * rcpDirMin)) * rcpFrame.xy;\n\n  vec3 rgbA = (1.0 / 2.0) * (\n    texture2D(uSampler, uv.xy + dir * (1.0 / 3.0 - 0.5)).xyz +\n    texture2D(uSampler, uv.xy + dir * (2.0 / 3.0 - 0.5)).xyz);\n  vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (\n    texture2D(uSampler, uv.xy + dir * (0.0 / 3.0 - 0.5)).xyz +\n    texture2D(uSampler, uv.xy + dir * (3.0 / 3.0 - 0.5)).xyz);\n\n  float lumaB = dot(rgbB, luma);\n\n  if (lumaB < lumaMin || lumaB > lumaMax) {\n    return vec4(rgbA.r, rgbA.g, rgbA.b, alpha);\n  }\n\n  return vec4(rgbB.r, rgbB.g, rgbB.b, alpha);\n}`,\n    // normal curve is a = 0 and b = 1\n    gaussian: `float gaussian(float x, float a, float b) {\n  float e = 2.71828;\n  return pow(e, -pow(x - a, 2.) / b);\n}`,\n    // for calculating the true distance from 0 to 1 depth buffer\n    // the small delta is to prevent division by zero, which is undefined behavior\n    truedepth: `float truedepth(float i) {\n  i = max(i, 0.00000001);\n  return (1. - i) / i;\n}`,\n    // based off of https://fabiensanglard.net/lightScattering/index.php\n    godrays: `vec4 godrays(\n  vec4 col,\n  float exposure,\n  float decay,\n  float density,\n  float weight,\n  vec2 lightPos,\n  float threshold,\n  vec4 newColor\n) {\n  vec2 texCoord = gl_FragCoord.xy / uResolution;\n  vec2 deltaTexCoord = texCoord - lightPos;\n\n  const int NUM_SAMPLES = 100;\n  deltaTexCoord *= 1. / float(NUM_SAMPLES) * density;\n  float illuminationDecay = 1.0;\n\n  for (int i=0; i < NUM_SAMPLES; i++) {\n    texCoord -= deltaTexCoord;\n    vec4 sample = texture2D(uSampler, texCoord);\n    //uncomment sample = depth2occlusion(sample, newColor, threshold);\n    sample *= illuminationDecay * weight;\n    col += sample;\n    illuminationDecay *= decay;\n  }\n  return col * exposure;\n}`,\n    depth2occlusion: `vec4 depth2occlusion(vec4 depthCol, vec4 newCol, float threshold) {\n  float red = 1. - ceil(depthCol.r - threshold);\n  return vec4(newCol.rgb * red, 1.0);\n}`,\n    // adapted from The Book of Shaders, which was adapted from Inigo Quilez\n    // from this example: https://www.shadertoy.com/view/XdXGW8\n    gradientnoise: `float gradientnoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(dot(random2(i + vec2(0.0,0.0)), f - vec2(0.0, 0.0)),\n                     dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)), u.x),\n             mix(dot(random2(i + vec2(0.0,1.0)), f - vec2(0.0, 1.0)),\n                 dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}`,\n    // adapted from The Book of Shaders\n    // https://thebookofshaders.com/edit.php#11/2d-snoise-clear.frag\n    // this was adapted from this fast implementation\n    // https://github.com/ashima/webgl-noise\n    // simplex noise invented by Ken Perlin\n    simplexnoise: `float simplexnoise(vec2 v) {\n  // Precompute values for skewed triangular grid\n  const vec4 C = vec4(0.211324865405187,\n                      // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,\n                      // 0.5*(sqrt(3.0)-1.0)\n                      -0.577350269189626,\n                      // -1.0 + 2.0 * C.x\n                      0.024390243902439);\n                      // 1.0 / 41.0\n\n  // First corner (x0)\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n\n  // Other two corners (x1, x2)\n  vec2 i1 = vec2(0.0);\n  i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n  vec2 x1 = x0.xy + C.xx - i1;\n  vec2 x2 = x0.xy + C.zz;\n\n  // Do some permutations to avoid\n  // truncation effects in permutation\n  i = mod289_2(i);\n  vec3 p = permute(\n          permute( i.y + vec3(0.0, i1.y, 1.0))\n              + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(\n                      dot(x0,x0),\n                      dot(x1,x1),\n                      dot(x2,x2)\n                      ), 0.0);\n\n  m = m*m ;\n  m = m*m ;\n\n  // Gradients:\n  //  41 pts uniformly over a line, mapped onto a diamond\n  //  The ring size 17*17 = 289 is close to a multiple\n  //      of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  // Normalise gradients implicitly by scaling m\n  // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n  // Compute final noise value at P\n  vec3 g = vec3(0.0);\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n  return 130.0 * dot(m, g);\n}`,\n    // only useful for simplex noise\n    simplexhelpers: `vec3 mod289_3(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289_3(((x*34.0)+1.0)*x); }`,\n    // sobel adapted from https://gist.github.com/Hebali/6ebfc66106459aacee6a9fac029d0115\n    sobel: `vec4 sobel() {\n  vec2 uv = gl_FragCoord.xy / uResolution;\n  vec4 k[8];\n\n  float w = 1. / uResolution.x;\n  float h = 1. / uResolution.y;\n\n  k[0] = texture2D(uSampler, uv + vec2(-w, -h));\n  k[1] = texture2D(uSampler, uv + vec2(0., -h));\n  k[2] = texture2D(uSampler, uv + vec2(w, -h));\n  k[3] = texture2D(uSampler, uv + vec2(-w, 0.));\n\n  k[4] = texture2D(uSampler, uv + vec2(w, 0.));\n  k[5] = texture2D(uSampler, uv + vec2(-w, h));\n  k[6] = texture2D(uSampler, uv + vec2(0., h));\n  k[7] = texture2D(uSampler, uv + vec2(w, h));\n\n  vec4 edge_h = k[2] + (2. * k[4]) + k[7] - (k[0] + (2. * k[3]) + k[5]);\n  vec4 edge_v = k[0] + (2. * k[1]) + k[2] - (k[5] + (2. * k[6]) + k[7]);\n  vec4 sob = sqrt(edge_h * edge_h + edge_v * edge_v);\n\n  return vec4(1. - sob.rgb, 1.);\n}`,\n    // inlining a similar function will substitute in the full expression for\n    // every component, so it's more efficient to have a function\n    monochrome: `vec4 monochrome(vec4 col) {\n  return vec4(vec3((col.r + col.g + col.b) / 3.), col.a);\n}`,\n    invert: `vec4 invert(vec4 col) {\n  return vec4(vec3(1., 1., 1.) - col.rgb, col.a);\n}`,\n    channel: `vec4 channel(vec2 uv, sampler2D sampler) {\n  return texture2D(sampler, uv);\n}`,\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.brandWithRegion = exports.brandWithChannel = exports.captureAndAppend = void 0;\nconst glslfunctions_1 = require(\"./glslfunctions\");\n/** @ignore */\nfunction captureAndAppend(str, reg, suffix) {\n    const matches = str.match(reg);\n    if (matches === null)\n        throw new Error(\"no match in the given string\");\n    return str.replace(reg, matches[0] + suffix);\n}\nexports.captureAndAppend = captureAndAppend;\n/** @ignore */\nfunction nameExtractor(sourceLists, extra) {\n    const origFuncName = sourceLists.sections[0];\n    const ending = origFuncName[origFuncName.length - 1] === \")\" ? \")\" : \"\";\n    const newFuncName = origFuncName.substr(0, origFuncName.length - 1 - ~~(ending === \")\")) +\n        extra +\n        \"(\" +\n        ending;\n    return { origFuncName, newFuncName, ending };\n}\n/** @ignore */\nfunction brandWithChannel(sourceLists, funcs, needs, funcIndex, samplerNum) {\n    samplerNum === undefined || samplerNum === -1\n        ? (needs.neighborSample = true)\n        : (needs.extraBuffers = new Set([samplerNum]));\n    if (samplerNum === undefined || samplerNum === -1)\n        return;\n    const { origFuncName, newFuncName, ending } = nameExtractor(sourceLists, samplerNum !== undefined ? \"_\" + samplerNum : \"\");\n    sourceLists.sections[0] = sourceLists.sections[0]\n        .split(origFuncName)\n        .join(newFuncName);\n    funcs[funcIndex] = funcs[funcIndex]\n        .split(origFuncName)\n        .join(newFuncName)\n        .split(\"uSampler\")\n        .join(\"uBufferSampler\" + samplerNum);\n}\nexports.brandWithChannel = brandWithChannel;\n/** @ignore */\nfunction brandWithRegion(expr, funcIndex, space) {\n    // if it's not a rectangle region we can't do anything so just return\n    if (!Array.isArray(space))\n        return;\n    const sourceLists = expr.sourceLists;\n    const funcs = expr.externalFuncs;\n    const needs = expr.needs;\n    if (expr.regionBranded ||\n        (!needs.neighborSample && needs.extraBuffers.size === 0))\n        return;\n    const { origFuncName, newFuncName, ending } = nameExtractor(sourceLists, \"_region\");\n    const openFuncName = newFuncName.substr(0, newFuncName.length - ~~(ending === \")\"));\n    const newFuncDeclaration = openFuncName +\n        \"float r_x_min, float r_y_min, float r_x_max, float r_y_max\" +\n        (ending === \")\" ? \")\" : \", \");\n    const origTextureName = \"texture2D(\";\n    const newTextureName = \"texture2D_region(r_x_min, r_y_min, r_x_max, r_y_max, \";\n    // replace name in the external function and `texture2D` and sampler\n    // (assumes the sampling function is the first external function)\n    funcs[funcIndex] = funcs[funcIndex]\n        .split(origFuncName)\n        .join(newFuncDeclaration)\n        .split(origTextureName)\n        .join(newTextureName);\n    // shift the original name off the list\n    sourceLists.sections.shift();\n    // add the close paren if we're opening up a function with 0 args\n    if (ending === \")\")\n        sourceLists.sections.unshift(\")\");\n    // add commas (one less if it is a 0 arg function call)\n    for (let i = 0; i < 4 - ~~(ending === \")\"); i++) {\n        sourceLists.sections.unshift(\", \");\n    }\n    // add the new name to the beginning of the list\n    sourceLists.sections.unshift(newFuncName.substr(0, newFuncName.length - ~~(ending === \")\")));\n    // add values from region data\n    sourceLists.values.unshift(...space);\n    // put the texture access wrapper at the beginning\n    funcs.unshift(glslfunctions_1.glslFuncs.texture2D_region);\n    expr.regionBranded = true;\n}\nexports.brandWithRegion = brandWithRegion;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tag = exports.wrapInValue = exports.pfloat = exports.Operator = exports.WrappedExpr = exports.ExprVec4 = exports.ExprVec3 = exports.ExprVec2 = exports.float = exports.ExprFloat = exports.BasicFloat = exports.ExprVec = exports.BasicVec4 = exports.BasicVec3 = exports.BasicVec2 = exports.BasicVec = exports.PrimitiveVec4 = exports.PrimitiveVec3 = exports.PrimitiveVec2 = exports.PrimitiveVec = exports.PrimitiveFloat = exports.Primitive = exports.mut = exports.Mutable = exports.cvec4 = exports.cvec3 = exports.cvec2 = exports.cfloat = exports.Expr = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst webglprogramloop_1 = require(\"../webglprogramloop\");\nconst utils_1 = require(\"../utils\");\n/**\n * adds a `.` after a number if needed (e.g converts `1` to `\"1.\"` but leaves\n * `1.2` as `\"1.2\"`)\n * @param num number to convert\n */\nfunction toGLSLFloatString(num) {\n    let str = \"\" + num;\n    if (!str.includes(\".\"))\n        str += \".\";\n    return str;\n}\nclass Expr {\n    constructor(sourceLists, defaultNames) {\n        // update me on change to needs\n        this.needs = {\n            neighborSample: false,\n            centerSample: false,\n            sceneBuffer: false,\n            timeUniform: false,\n            mouseUniform: false,\n            passCount: false,\n            extraBuffers: new Set(),\n        };\n        this.uniformValChangeMap = {};\n        this.defaultNameMap = {};\n        this.externalFuncs = [];\n        this.sourceCode = \"\";\n        this.funcIndex = 0;\n        this.regionBranded = false;\n        this.id = \"_id_\" + Expr.count;\n        Expr.count++;\n        if (sourceLists.sections.length - sourceLists.values.length !== 1) {\n            // this cannot happen if you use `tag` to destructure a template string\n            throw new Error(\"wrong lengths for source and values\");\n        }\n        if (sourceLists.values.length !== defaultNames.length) {\n            console.log(sourceLists);\n            console.log(defaultNames);\n            throw new Error(\"default names list length doesn't match values list length\");\n        }\n        this.sourceLists = sourceLists;\n        this.defaultNames = defaultNames;\n    }\n    applyUniforms(gl, uniformLocs) {\n        for (const name in this.uniformValChangeMap) {\n            const loc = uniformLocs[name];\n            if (this.uniformValChangeMap[name].changed) {\n                //this.uniformValChangeMap[name].changed = false;\n                this.uniformValChangeMap[name].val.applyUniform(gl, loc.locs[loc.counter]);\n            }\n            // increment and reset the counter to wrap back around to first location\n            loc.counter++;\n            loc.counter %= loc.locs.length;\n            // once we have wrapped then we know all uniforms have been changed\n            if (loc.counter === 0) {\n                this.uniformValChangeMap[name].changed = false;\n            }\n        }\n    }\n    getSampleNum(mult = 1) {\n        return this.needs.neighborSample\n            ? mult\n            : this.sourceLists.values\n                .map((v) => v.getSampleNum())\n                .reduce((acc, curr) => acc + curr, 0) > 0\n                ? mult\n                : 0;\n    }\n    /**\n     * set a uniform by name directly\n     * @param name uniform name in the source code\n     * @param newVal value to set the uniform to\n     */\n    setUniform(name, newVal) {\n        var _a, _b;\n        newVal = wrapInValue(newVal);\n        const originalName = name;\n        if (typeof newVal === \"number\") {\n            newVal = wrapInValue(newVal);\n        }\n        if (!(newVal instanceof Primitive)) {\n            throw new Error(\"cannot set a non-primitive\");\n        }\n        // if name does not exist, try mapping default name to new name\n        if (((_a = this.uniformValChangeMap[name]) === null || _a === void 0 ? void 0 : _a.val) === undefined) {\n            name = this.defaultNameMap[name];\n        }\n        const oldVal = (_b = this.uniformValChangeMap[name]) === null || _b === void 0 ? void 0 : _b.val;\n        if (oldVal === undefined) {\n            throw new Error(\"tried to set uniform \" +\n                name +\n                \" which doesn't exist. original name: \" +\n                originalName);\n        }\n        if (oldVal.typeString() !== newVal.typeString()) {\n            throw new Error(\"tried to set uniform \" + name + \" to a new type\");\n        }\n        this.uniformValChangeMap[name].val = newVal;\n        this.uniformValChangeMap[name].changed = true;\n    }\n    /**\n     * parses this expression into a string, adding info as it recurses into\n     * nested expressions\n     */\n    parse(buildInfo) {\n        this.sourceCode = \"\";\n        buildInfo.exprs.push(this);\n        buildInfo.needs = webglprogramloop_1.updateNeeds(buildInfo.needs, this.needs);\n        // add each of the external funcs to the builder\n        this.externalFuncs.forEach((func) => buildInfo.externalFuncs.add(func));\n        // put all of the values between all of the source sections\n        for (let i = 0; i < this.sourceLists.values.length; i++) {\n            this.sourceCode +=\n                this.sourceLists.sections[i] +\n                    this.sourceLists.values[i].parse(buildInfo, this.defaultNames[i], this);\n        }\n        // TODO does sourceCode have to be a member?\n        this.sourceCode += this.sourceLists.sections[this.sourceLists.sections.length - 1];\n        return this.sourceCode;\n    }\n    addFuncs(funcs) {\n        this.externalFuncs.push(...funcs);\n        return this;\n    }\n    brandExprWithChannel(funcIndex, samplerNum) {\n        utils_1.brandWithChannel(this.sourceLists, this.externalFuncs, this.needs, funcIndex, samplerNum);\n        return this;\n    }\n    brandExprWithRegion(space) {\n        utils_1.brandWithRegion(this, this.funcIndex, space);\n        for (const v of this.sourceLists.values) {\n            v.brandExprWithRegion(space);\n        }\n        return this;\n    }\n}\nexports.Expr = Expr;\n/**\n * increments for each expression created; used to uniquely id each expression\n */\nExpr.count = 0;\nfunction genCustomNames(sourceLists) {\n    const names = [];\n    for (let i = 0; i < sourceLists.values.length; i++) {\n        names.push(\"uCustomName\" + i);\n    }\n    return names;\n}\n/** create a custom float function (use with [[tag]]) */\nfunction cfloat(sourceLists, externalFuncs = []) {\n    return new ExprFloat(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);\n}\nexports.cfloat = cfloat;\n/** create a custom vec2 function (use with [[tag]]) */\nfunction cvec2(sourceLists, externalFuncs = []) {\n    return new ExprVec2(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);\n}\nexports.cvec2 = cvec2;\n/** create a custom vec3 function (use with [[tag]]) */\nfunction cvec3(sourceLists, externalFuncs = []) {\n    return new ExprVec3(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);\n}\nexports.cvec3 = cvec3;\n/** create a custom vec4 function (use with [[tag]]) */\nfunction cvec4(sourceLists, externalFuncs = []) {\n    return new ExprVec4(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);\n}\nexports.cvec4 = cvec4;\nclass Mutable {\n    constructor(primitive, name) {\n        this.primitive = primitive;\n        this.name = name;\n    }\n    parse(buildInfo, defaultName, enc) {\n        if (enc === undefined) {\n            throw new Error(\"tried to put a mutable expression at the top level\");\n        }\n        // accept the default name if given no name\n        if (this.name === undefined)\n            this.name = defaultName + enc.id;\n        // set to true so they are set to their default values on first draw\n        buildInfo.uniformTypes[this.name] = this.primitive.typeString();\n        // add the name mapping\n        enc.uniformValChangeMap[this.name] = {\n            val: this.primitive,\n            changed: true,\n        };\n        // add the new type to the map\n        enc.defaultNameMap[defaultName + enc.id] = this.name;\n        return this.name;\n    }\n    applyUniform(gl, loc) {\n        this.primitive.applyUniform(gl, loc);\n    }\n    typeString() {\n        return this.primitive.typeString();\n    }\n    getSampleNum() {\n        return 0;\n    }\n    brandExprWithRegion(space) {\n        return this;\n    }\n}\nexports.Mutable = Mutable;\n/**\n * makes a primitive value mutable. wrapping a [[PrimitiveVec]] or\n * [[PrimitiveFloat]] in [[mut]] before passing it into an expression will\n * allow you to use the setters on that expression to change those values at\n * runtime\n * @param val the primitive float or primitive vec to make mutable\n * @param name the optional name for the uniform\n */\nfunction mut(val, name) {\n    const primitive = typeof val === \"number\" ? wrapInValue(val) : val;\n    return new Mutable(primitive, name);\n}\nexports.mut = mut;\nclass Primitive {\n    parse() {\n        return this.toString();\n    }\n    getSampleNum() {\n        return 0;\n    }\n    brandExprWithRegion(space) {\n        return this;\n    }\n}\nexports.Primitive = Primitive;\nclass PrimitiveFloat extends Primitive {\n    constructor(num) {\n        if (!isFinite(num))\n            throw new Error(\"number not finite\");\n        super();\n        this.value = num;\n    }\n    toString() {\n        let str = \"\" + this.value;\n        if (!str.includes(\".\"))\n            str += \".\";\n        return str;\n    }\n    typeString() {\n        return \"float\";\n    }\n    applyUniform(gl, loc) {\n        gl.uniform1f(loc, this.value);\n    }\n}\nexports.PrimitiveFloat = PrimitiveFloat;\nclass PrimitiveVec extends Primitive {\n    constructor(comps) {\n        super();\n        this.values = comps;\n    }\n    typeString() {\n        return (\"vec\" + this.values.length);\n    }\n    toString() {\n        return `${this.typeString()}(${this.values\n            .map((n) => toGLSLFloatString(n))\n            .join(\", \")})`;\n    }\n}\nexports.PrimitiveVec = PrimitiveVec;\nclass PrimitiveVec2 extends PrimitiveVec {\n    applyUniform(gl, loc) {\n        gl.uniform2f(loc, this.values[0], this.values[1]);\n    }\n}\nexports.PrimitiveVec2 = PrimitiveVec2;\nclass PrimitiveVec3 extends PrimitiveVec {\n    applyUniform(gl, loc) {\n        gl.uniform3f(loc, this.values[0], this.values[1], this.values[2]);\n    }\n}\nexports.PrimitiveVec3 = PrimitiveVec3;\nclass PrimitiveVec4 extends PrimitiveVec {\n    applyUniform(gl, loc) {\n        gl.uniform4f(loc, this.values[0], this.values[1], this.values[2], this.values[3]);\n    }\n}\nexports.PrimitiveVec4 = PrimitiveVec4;\nclass BasicVec extends Expr {\n    constructor(sourceLists, defaultNames) {\n        super(sourceLists, defaultNames);\n        // this cast is fine as long as you only instantiate these with the\n        // shorthand version and not the constructor\n        const values = sourceLists.values;\n        this.values = values;\n        this.defaultNames = defaultNames;\n    }\n    typeString() {\n        return (\"vec\" + this.values.length);\n    }\n    /** sets a component of the vector */\n    setComp(index, primitive) {\n        if (index < 0 || index >= this.values.length) {\n            throw new Error(\"out of bounds of setting component\");\n        }\n        this.setUniform(this.defaultNames[index] + this.id, wrapInValue(primitive));\n    }\n}\nexports.BasicVec = BasicVec;\nclass BasicVec2 extends BasicVec {\n    constructor() {\n        super(...arguments);\n        this.bvec2 = undefined; // brand for nominal typing\n    }\n}\nexports.BasicVec2 = BasicVec2;\nclass BasicVec3 extends BasicVec {\n    constructor() {\n        super(...arguments);\n        this.bvec3 = undefined; // brand for nominal typing\n    }\n}\nexports.BasicVec3 = BasicVec3;\nclass BasicVec4 extends BasicVec {\n    constructor() {\n        super(...arguments);\n        this.bvec4 = undefined; // brand for nominal typing\n    }\n}\nexports.BasicVec4 = BasicVec4;\nclass ExprVec extends Expr {\n    constructor(sourceLists, defaultNames) {\n        super(sourceLists, defaultNames);\n        const values = sourceLists.values;\n        this.values = values;\n        this.defaultNames = defaultNames;\n    }\n}\nexports.ExprVec = ExprVec;\nclass BasicFloat extends Expr {\n    constructor(sourceLists, defaultNames) {\n        super(sourceLists, defaultNames);\n        this.float = undefined; // brand for nominal typing\n    }\n    setVal(primitive) {\n        this.setUniform(\"uFloat\" + this.id, wrapInValue(primitive));\n    }\n    typeString() {\n        return \"float\";\n    }\n}\nexports.BasicFloat = BasicFloat;\nclass ExprFloat extends Expr {\n    constructor(sourceLists, defaultNames) {\n        super(sourceLists, defaultNames);\n        this.float = undefined; // brand for nominal typing\n    }\n    setVal(primitive) {\n        this.setUniform(\"uFloat\" + this.id, wrapInValue(primitive));\n    }\n    typeString() {\n        return \"float\";\n    }\n}\nexports.ExprFloat = ExprFloat;\nfunction float(value) {\n    if (typeof value === \"number\")\n        value = wrapInValue(value);\n    return new BasicFloat({ sections: [\"\", \"\"], values: [value] }, [\"uFloat\"]);\n}\nexports.float = float;\nclass ExprVec2 extends ExprVec {\n    constructor() {\n        super(...arguments);\n        this.vec2 = undefined; // brand for nominal typing\n    }\n    typeString() {\n        return \"vec2\";\n    }\n}\nexports.ExprVec2 = ExprVec2;\nclass ExprVec3 extends ExprVec {\n    constructor() {\n        super(...arguments);\n        this.vec3 = undefined; // brand for nominal typing\n    }\n    typeString() {\n        return \"vec3\";\n    }\n}\nexports.ExprVec3 = ExprVec3;\nclass ExprVec4 extends ExprVec {\n    constructor() {\n        super(...arguments);\n        this.vec4 = undefined; // brand for nominal typing\n    }\n    repeat(num) {\n        return new mergepass_1.EffectLoop([this], { num: num });\n    }\n    genPrograms(gl, vShader, uniformLocs, shaders) {\n        return new mergepass_1.EffectLoop([this], { num: 1 }).genPrograms(gl, vShader, uniformLocs, shaders);\n    }\n    typeString() {\n        return \"vec4\";\n    }\n}\nexports.ExprVec4 = ExprVec4;\nclass WrappedExpr {\n    constructor(expr) {\n        this.expr = expr;\n    }\n    typeString() {\n        return this.expr.typeString();\n    }\n    parse(buildInfo, defaultName, enc) {\n        return this.expr.parse(buildInfo, defaultName, enc);\n    }\n    getSampleNum() {\n        return this.expr.getSampleNum();\n    }\n    brandExprWithRegion(space) {\n        return this.expr.brandExprWithRegion(space);\n    }\n}\nexports.WrappedExpr = WrappedExpr;\nclass Operator extends Expr {\n    constructor(ret, sourceLists, defaultNames) {\n        super(sourceLists, defaultNames);\n        this.ret = ret;\n    }\n    typeString() {\n        return this.ret.typeString();\n    }\n}\nexports.Operator = Operator;\n/** creates a primitive float */\nfunction pfloat(num) {\n    return new PrimitiveFloat(num);\n}\nexports.pfloat = pfloat;\nfunction wrapInValue(num) {\n    if (num === undefined)\n        return undefined;\n    if (typeof num === \"number\")\n        return pfloat(num);\n    return num;\n}\nexports.wrapInValue = wrapInValue;\n/**\n * takes a template strings array and converts it to a source list; very useful\n * for [[cfloat]], [[cvec2]], [[cvec3]] and [[cvec4]]\n */\nfunction tag(strings, ...values) {\n    return { sections: strings.concat([]), values: values };\n}\nexports.tag = tag;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeBuilder = exports.channelSamplerName = void 0;\nconst expr_1 = require(\"./exprs/expr\");\nconst webglprogramloop_1 = require(\"./webglprogramloop\");\nconst settings_1 = require(\"./settings\");\n/** @ignore */\nconst FRAG_SET = `  gl_FragColor = texture2D(uSampler, gl_FragCoord.xy / uResolution);\\n`;\n/** @ignore */\nconst SCENE_SET = `uniform sampler2D uSceneSampler;\\n`;\n/** @ignore */\nconst TIME_SET = `uniform mediump float uTime;\\n`;\n/** @ignore */\nconst MOUSE_SET = `uniform mediump vec2 uMouse;\\n`;\n/** @ignore */\nconst COUNT_SET = `uniform int uCount;\\n`;\n/** @ignore */\nconst BOILERPLATE = `#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform sampler2D uSampler;\nuniform mediump vec2 uResolution;\\n`;\n/**\n * returns the string name of the sampler uniform for code generation purposes\n * @param num channel number to sample from\n */\nfunction channelSamplerName(num) {\n    // texture 2 sampler has number 0 (0 and 1 are used for back buffer and scene)\n    return num === -1 ? \"uSampler\" : `uBufferSampler${num}`;\n}\nexports.channelSamplerName = channelSamplerName;\n/**\n * returns the string of the declaration of the sampler for code generation\n * purposes\n * @param num channel number to sample from\n */\nfunction channelSamplerDeclaration(num) {\n    return `uniform sampler2D ${channelSamplerName(num)};`;\n}\n/** class that manages generation and compilation of GLSL code */\nclass CodeBuilder {\n    constructor(effectLoop) {\n        this.calls = [];\n        this.externalFuncs = new Set();\n        this.uniformDeclarations = new Set();\n        this.counter = 0;\n        this.baseLoop = effectLoop;\n        const buildInfo = {\n            uniformTypes: {},\n            externalFuncs: new Set(),\n            exprs: [],\n            // update me on change to needs\n            needs: {\n                centerSample: false,\n                neighborSample: false,\n                sceneBuffer: false,\n                timeUniform: false,\n                mouseUniform: false,\n                passCount: false,\n                extraBuffers: new Set(),\n            },\n        };\n        this.addEffectLoop(effectLoop, 1, buildInfo);\n        // add all the types to uniform declarations from the `BuildInfo` instance\n        for (const name in buildInfo.uniformTypes) {\n            const typeName = buildInfo.uniformTypes[name];\n            this.uniformDeclarations.add(`uniform mediump ${typeName} ${name};`);\n        }\n        // add all external functions from the `BuildInfo` instance\n        buildInfo.externalFuncs.forEach((func) => this.externalFuncs.add(func));\n        this.totalNeeds = buildInfo.needs;\n        this.exprs = buildInfo.exprs;\n    }\n    addEffectLoop(effectLoop, indentLevel, buildInfo, topLevel = true) {\n        const needsLoop = !topLevel && effectLoop.loopInfo.num > 1;\n        if (needsLoop) {\n            const iName = \"i\" + this.counter;\n            indentLevel++;\n            const forStart = \"  \".repeat(indentLevel - 1) +\n                `for (int ${iName} = 0; ${iName} < ${effectLoop.loopInfo.num}; ${iName}++) {`;\n            this.calls.push(forStart);\n        }\n        for (const e of effectLoop.effects) {\n            if (e instanceof expr_1.Expr) {\n                e.parse(buildInfo);\n                this.calls.push(\"  \".repeat(indentLevel) + \"gl_FragColor = \" + e.sourceCode + \";\");\n                this.counter++;\n            }\n            else {\n                this.addEffectLoop(e, indentLevel, buildInfo, false);\n            }\n        }\n        if (needsLoop) {\n            this.calls.push(\"  \".repeat(indentLevel - 1) + \"}\");\n        }\n    }\n    /** generate the code and compile the program into a loop */\n    compileProgram(gl, vShader, uniformLocs, shaders = []) {\n        // set up the fragment shader\n        const fShader = gl.createShader(gl.FRAGMENT_SHADER);\n        if (fShader === null) {\n            throw new Error(\"problem creating fragment shader\");\n        }\n        const fullCode = BOILERPLATE +\n            (this.totalNeeds.sceneBuffer ? SCENE_SET : \"\") +\n            (this.totalNeeds.timeUniform ? TIME_SET : \"\") +\n            (this.totalNeeds.mouseUniform ? MOUSE_SET : \"\") +\n            (this.totalNeeds.passCount ? COUNT_SET : \"\") +\n            Array.from(this.totalNeeds.extraBuffers)\n                .map((n) => channelSamplerDeclaration(n))\n                .join(\"\\n\") +\n            \"\\n\" +\n            [...this.uniformDeclarations].join(\"\\n\") +\n            \"\\n\" +\n            [...this.externalFuncs].join(\"\\n\") +\n            \"\\n\" +\n            \"void main() {\\n\" +\n            (this.totalNeeds.centerSample ? FRAG_SET : \"\") +\n            this.calls.join(\"\\n\") +\n            \"\\n}\";\n        if (settings_1.settings.verbosity > 0)\n            console.log(fullCode);\n        gl.shaderSource(fShader, fullCode);\n        gl.compileShader(fShader);\n        // set up the program\n        const program = gl.createProgram();\n        if (program === null) {\n            throw new Error(\"problem creating program\");\n        }\n        gl.attachShader(program, vShader);\n        gl.attachShader(program, fShader);\n        shaders.push(fShader);\n        const shaderLog = (name, shader) => {\n            const output = gl.getShaderInfoLog(shader);\n            if (output)\n                console.log(`${name} shader info log\\n${output}`);\n        };\n        shaderLog(\"vertex\", vShader);\n        shaderLog(\"fragment\", fShader);\n        gl.linkProgram(program);\n        // we need to use the program here so we can get uniform locations\n        gl.useProgram(program);\n        // find all uniform locations and add them to the dictionary\n        for (const expr of this.exprs) {\n            for (const name in expr.uniformValChangeMap) {\n                const location = gl.getUniformLocation(program, name);\n                if (location === null) {\n                    throw new Error(\"couldn't find uniform \" + name);\n                }\n                // TODO enforce unique names in the same program\n                if (uniformLocs[name] === undefined) {\n                    uniformLocs[name] = { locs: [], counter: 0 };\n                }\n                // assign the name to the location\n                uniformLocs[name].locs.push(location);\n            }\n        }\n        // set the uniform resolution (every program has this uniform)\n        const uResolution = gl.getUniformLocation(program, \"uResolution\");\n        gl.uniform2f(uResolution, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        if (this.totalNeeds.sceneBuffer) {\n            // TODO allow for texture options for scene texture\n            const location = gl.getUniformLocation(program, \"uSceneSampler\");\n            // put the scene buffer in texture 1 (0 is used for the backbuffer)\n            gl.uniform1i(location, 1 + settings_1.settings.offset);\n        }\n        // set all sampler uniforms\n        for (const b of this.totalNeeds.extraBuffers) {\n            const location = gl.getUniformLocation(program, channelSamplerName(b));\n            // offset the texture location by 2 (0 and 1 are used for scene and original)\n            gl.uniform1i(location, b + 2 + settings_1.settings.offset);\n        }\n        // set the default sampler if there is an offset\n        if (settings_1.settings.offset !== 0) {\n            const location = gl.getUniformLocation(program, \"uSampler\");\n            gl.uniform1i(location, settings_1.settings.offset);\n        }\n        // TODO do we need to do this every time?\n        // get attribute\n        const position = gl.getAttribLocation(program, \"aPosition\");\n        // enable the attribute\n        gl.enableVertexAttribArray(position);\n        // points to the vertices in the last bound array buffer\n        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);\n        return new webglprogramloop_1.WebGLProgramLoop(new webglprogramloop_1.WebGLProgramLeaf(program, this.totalNeeds, this.exprs), this.baseLoop.loopInfo, gl);\n    }\n}\nexports.CodeBuilder = CodeBuilder;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fcolor = exports.FragColorExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** fragment color expression */\nclass FragColorExpr extends expr_1.ExprVec4 {\n    constructor() {\n        super(expr_1.tag `gl_FragColor`, []);\n        this.needs.centerSample = true;\n    }\n}\nexports.FragColorExpr = FragColorExpr;\n/** creates an expression that evaluates to the fragment color */\nfunction fcolor() {\n    return new FragColorExpr();\n}\nexports.fcolor = fcolor;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.get4comp = exports.get3comp = exports.get2comp = exports.getcomp = exports.Get4CompExpr = exports.Get3CompExpr = exports.Get2CompExpr = exports.GetCompExpr = exports.checkLegalComponents = exports.typeStringToLength = void 0;\nconst expr_1 = require(\"./expr\");\n// TODO this should probably be somewhere else\n/** @ignore */\nfunction typeStringToLength(str) {\n    switch (str) {\n        case \"float\":\n            return 1;\n        case \"vec2\":\n            return 2;\n        case \"vec3\":\n            return 3;\n        case \"vec4\":\n            return 4;\n    }\n}\nexports.typeStringToLength = typeStringToLength;\n/** @ignore */\nfunction genCompSource(vec, components) {\n    return {\n        sections: [\"\", \".\" + components],\n        values: [vec],\n    };\n}\n/**\n * checks if components accessing a vector are legal. components can be illegal\n * if they mix sets (e.g. `v.rgzw`) or contain characters outside of any set\n * (e.g. `v.lmno`)\n * @param comps components string\n * @param vec vector being accessed\n */\nfunction checkLegalComponents(comps, vec) {\n    const check = (range, domain) => {\n        let inside = 0;\n        let outside = 0;\n        for (const c of range) {\n            domain.includes(c) ? inside++ : outside++;\n        }\n        return inside === inside && !outside;\n    };\n    const inLen = typeStringToLength(vec.typeString());\n    const rgbaCheck = check(comps, \"rgba\".substr(0, inLen));\n    const xyzwCheck = check(comps, \"xyzw\".substr(0, inLen));\n    const stpqCheck = check(comps, \"stpq\".substr(0, inLen));\n    if (!(rgbaCheck || xyzwCheck || stpqCheck)) {\n        throw new Error(\"component sets are mixed or incorrect entirely\");\n    }\n}\nexports.checkLegalComponents = checkLegalComponents;\n/**\n * performs all validity checks of [[checkLegalComponents]] and checks if the\n * number of accessed components does not exceed the size of the vector being\n * assigned to\n * @param comps components string\n * @param outLen length of the resultant vector\n * @param vec vector being accessed\n */\nfunction checkGetComponents(comps, outLen, vec) {\n    if (comps.length > outLen)\n        throw new Error(\"too many components\");\n    checkLegalComponents(comps, vec);\n}\n/** get component expression */\nclass GetCompExpr extends expr_1.ExprFloat {\n    constructor(vec, comps) {\n        checkGetComponents(comps, 1, vec);\n        super(genCompSource(vec, comps), [\"uVec1Min\"]);\n        this.vec1Min = vec;\n    }\n    setVec(vec) {\n        this.setUniform(\"uVec1Min\", vec);\n        this.vec1Min = vec;\n    }\n}\nexports.GetCompExpr = GetCompExpr;\n/** get 2 components expression */\nclass Get2CompExpr extends expr_1.ExprVec2 {\n    constructor(vec, comps) {\n        checkGetComponents(comps, 2, vec);\n        super(genCompSource(vec, comps), [\"uVec2Min\"]);\n        this.vec2Min = vec;\n    }\n    setVec(vec) {\n        this.setUniform(\"uVec2Min\", vec);\n        this.vec2Min = vec;\n    }\n}\nexports.Get2CompExpr = Get2CompExpr;\n/** get 3 components expression */\nclass Get3CompExpr extends expr_1.ExprVec3 {\n    constructor(vec, comps) {\n        checkGetComponents(comps, 3, vec);\n        super(genCompSource(vec, comps), [\"uVec3Min\"]);\n        this.vec3Min = vec;\n    }\n    setVec(vec) {\n        this.setUniform(\"uVec3Min\", vec);\n        this.vec3Min = vec;\n    }\n}\nexports.Get3CompExpr = Get3CompExpr;\n/** get 3 components expression */\nclass Get4CompExpr extends expr_1.ExprVec4 {\n    constructor(vec, comps) {\n        checkGetComponents(comps, 4, vec);\n        super(genCompSource(vec, comps), [\"uVec4Min\"]);\n        this.vec4Min = vec;\n    }\n    setVec(vec) {\n        this.setUniform(\"uVec4Min\", vec);\n        this.vec4Min = vec;\n    }\n}\nexports.Get4CompExpr = Get4CompExpr;\n/**\n * creates an expression that gets 1 component from a vector\n * @param vec the vector to get components of\n * @param comps components string\n */\nfunction getcomp(vec, comps) {\n    return new GetCompExpr(vec, comps);\n}\nexports.getcomp = getcomp;\n/**\n * creates an expression that gets 2 components from a vector\n * @param vec the vector to get components of\n * @param comps components string\n */\nfunction get2comp(vec, comps) {\n    return new Get2CompExpr(vec, comps);\n}\nexports.get2comp = get2comp;\n/**\n * creates an expression that gets 3 components from a vector\n * @param vec the vector to get components of\n * @param comps components string\n */\nfunction get3comp(vec, comps) {\n    return new Get3CompExpr(vec, comps);\n}\nexports.get3comp = get3comp;\n/**\n * creates an expression that gets 4 components from a vector\n * @param vec the vector to get components of\n * @param comps components string\n */\nfunction get4comp(vec, comps) {\n    return new Get4CompExpr(vec, comps);\n}\nexports.get4comp = get4comp;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pos = exports.NormFragCoordExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** normalized frag coord expression */\nclass NormFragCoordExpr extends expr_1.ExprVec2 {\n    constructor() {\n        // don't remove these parens! even if you think you are being clever about\n        // order of operations\n        super(expr_1.tag `(gl_FragCoord.xy / uResolution)`, []);\n    }\n}\nexports.NormFragCoordExpr = NormFragCoordExpr;\n/**\n * creates an expression that calculates the normalized frag coord (coordinates\n * range from 0 to 1)\n */\nfunction pos() {\n    return new NormFragCoordExpr();\n}\nexports.pos = pos;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.op = exports.OpExpr = void 0;\nconst expr_1 = require(\"./expr\");\nfunction genOpSourceList(left, op, right) {\n    return {\n        sections: [\"(\", ` ${op} `, \")\"],\n        values: [left, right],\n    };\n}\nclass OpExpr extends expr_1.Operator {\n    constructor(left, op, right) {\n        super(left, genOpSourceList(left, op, right), [\"uLeft\", \"uRight\"]);\n        this.left = left;\n        this.right = right;\n    }\n    setLeft(left) {\n        this.setUniform(\"uLeft\" + this.id, left);\n        this.left = expr_1.wrapInValue(left);\n    }\n    setRight(right) {\n        this.setUniform(\"uRight\" + this.id, right);\n        this.right = expr_1.wrapInValue(right);\n    }\n}\nexports.OpExpr = OpExpr;\n// implementation\n/**\n * creates an arithmetic operator expression\n * @param left expression left of operator\n * @param op string representing arithmetic operator\n * @param right expression right of operator\n */\nfunction op(left, op, right) {\n    return new OpExpr(expr_1.wrapInValue(left), op, expr_1.wrapInValue(right));\n}\nexports.op = op;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ternary = exports.TernaryExpr = void 0;\nconst expr_1 = require(\"./expr\");\nfunction genTernarySourceList(floats, success, failure, not) {\n    const sourceList = {\n        sections: [`(${not ? \"!\" : \"\"}(`],\n        values: [],\n    };\n    let counter = 0;\n    // generate the boolean expression\n    if (floats !== null) {\n        for (const f of floats) {\n            counter++;\n            const last = counter === floats.length;\n            sourceList.values.push(f);\n            sourceList.sections.push(` > 0.${last ? \") ? \" : \" && \"}`);\n        }\n    }\n    else {\n        sourceList.sections[0] += \"uCount == 0) ? \";\n    }\n    // generate the success expression and colon\n    sourceList.values.push(success);\n    sourceList.sections.push(\" : \");\n    // generate the failure expression\n    sourceList.values.push(failure);\n    sourceList.sections.push(\")\");\n    return sourceList;\n}\nclass TernaryExpr extends expr_1.Operator {\n    constructor(floats, success, failure, not) {\n        super(success, genTernarySourceList(floats, success, failure, not), [\n            ...(floats !== null\n                ? Array.from(floats, (val, index) => \"uFloat\" + index)\n                : []),\n            \"uSuccess\",\n            \"uFailure\",\n        ]);\n        this.success = success;\n        this.failure = failure;\n        this.needs.passCount = floats === null;\n    }\n}\nexports.TernaryExpr = TernaryExpr;\n/**\n * creates a ternary expression; the boolean expression is if all the floats\n * given are greater than 0\n * @param floats if all these floats (or the single float) are above 0, then\n * evaluates to success expression\n * @param success\n * @param failure\n * @param not whether to invert the ternary\n */\nfunction ternary(floats, success, failure, not = false) {\n    // TODO make this type safe (ran into a type error here)\n    // wrap single float in array if need be\n    if (!Array.isArray(floats) && floats !== null)\n        floats = [floats].map((f) => expr_1.wrapInValue(f));\n    // TODO get rid of this cast\n    return new TernaryExpr(floats, expr_1.wrapInValue(success), expr_1.wrapInValue(failure), not);\n}\nexports.ternary = ternary;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.region = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst expr_1 = require(\"./expr\");\nconst getcompexpr_1 = require(\"./getcompexpr\");\nconst normfragcoordexpr_1 = require(\"./normfragcoordexpr\");\nconst opexpr_1 = require(\"./opexpr\");\nconst ternaryexpr_1 = require(\"./ternaryexpr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\n// form: x1, y1, x2, y2\nfunction createDifferenceFloats(floats) {\n    const axes = \"xy\";\n    const differences = [];\n    if (floats.length !== 4) {\n        throw new Error(\"incorrect amount of points specified for region\");\n    }\n    for (let i = 0; i < 2; i++) {\n        differences.push(opexpr_1.op(getcompexpr_1.getcomp(normfragcoordexpr_1.pos(), axes[i]), \"-\", floats[i]));\n    }\n    for (let i = 2; i < floats.length; i++) {\n        differences.push(opexpr_1.op(floats[i], \"-\", getcompexpr_1.getcomp(normfragcoordexpr_1.pos(), axes[i - 2])));\n    }\n    return differences;\n}\n/**\n * restrict an effect to a region of the screen\n * @param space top left, top right, bottom left, bottom right corners of the\n * region, or just a number if you wish to sample from a channel as the region\n * @param success expression for being inside the region\n * @param failure expression for being outside the region\n * @param not whether to invert the region\n */\nfunction region(space, success, failure, not = false) {\n    const floats = Array.isArray(space)\n        ? space.map((f) => expr_1.wrapInValue(f))\n        : typeof space === \"number\"\n            ? expr_1.wrapInValue(space)\n            : space;\n    if (failure instanceof mergepass_1.EffectLoop) {\n        if (!(success instanceof mergepass_1.EffectLoop)) {\n            [success, failure] = [failure, success]; // swap the order\n            not = !not; // invert the region\n        }\n    }\n    if (success instanceof mergepass_1.EffectLoop) {\n        if (!(failure instanceof mergepass_1.EffectLoop)) {\n            return success.regionWrap(floats, failure, true, not);\n        }\n        // double loop, so we have to do separately\n        return mergepass_1.loop([\n            success.regionWrap(floats, fragcolorexpr_1.fcolor(), false, not),\n            failure.regionWrap(floats, fragcolorexpr_1.fcolor(), true, !not),\n        ]);\n    }\n    return ternaryexpr_1.ternary(Array.isArray(floats) ? createDifferenceFloats(floats) : floats, success.brandExprWithRegion(floats), failure.brandExprWithRegion(floats), not);\n}\nexports.region = region;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.input = exports.SceneSampleExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst normfragcoordexpr_1 = require(\"./normfragcoordexpr\");\n/** scene sample expression */\nclass SceneSampleExpr extends expr_1.ExprVec4 {\n    constructor(coord = normfragcoordexpr_1.pos()) {\n        super(expr_1.tag `texture2D(uSceneSampler, ${coord})`, [\"uCoord\"]);\n        this.coord = coord;\n        this.needs.sceneBuffer = true;\n    }\n    /** sets coordinate where scene is being sampled from */\n    setCoord(coord) {\n        this.setUniform(\"uCoord\", coord);\n        this.coord = coord;\n    }\n}\nexports.SceneSampleExpr = SceneSampleExpr;\n/**\n * creates an expression that samples the original scene\n * @param vec where to sample the original scene texture (defaults to the\n * normalized frag coord, but change this if you want to transform the\n * coordinate space of the original image)\n */\nfunction input(vec) {\n    return new SceneSampleExpr(vec);\n}\nexports.input = input;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetColorExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/**\n * set fragment color expression (not needed for the user; used internally for\n * wrapping any kind of [[Vec4]] in an [[ExprVec4]])\n */\nclass SetColorExpr extends expr_1.ExprVec4 {\n    constructor(vec) {\n        super(expr_1.tag `(${vec})`, [\"uVal\"]);\n        this.vec = vec;\n    }\n}\nexports.SetColorExpr = SetColorExpr;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sendTexture = exports.makeTexture = exports.Merger = exports.loop = exports.EffectLoop = exports.EffectDictionary = void 0;\nconst codebuilder_1 = require(\"./codebuilder\");\nconst expr_1 = require(\"./exprs/expr\");\nconst fragcolorexpr_1 = require(\"./exprs/fragcolorexpr\");\nconst regiondecorator_1 = require(\"./exprs/regiondecorator\");\nconst scenesampleexpr_1 = require(\"./exprs/scenesampleexpr\");\nconst setcolorexpr_1 = require(\"./exprs/setcolorexpr\");\nconst ternaryexpr_1 = require(\"./exprs/ternaryexpr\");\nconst settings_1 = require(\"./settings\");\nconst webglprogramloop_1 = require(\"./webglprogramloop\");\nfunction wrapInSetColors(effects) {\n    return effects.map((e) => e instanceof expr_1.ExprVec4 || e instanceof EffectLoop ? e : new setcolorexpr_1.SetColorExpr(e));\n}\n// should be function of loop?\nfunction processEffectMap(eMap) {\n    const result = {};\n    for (const name in eMap) {\n        const val = eMap[name];\n        result[name] = wrapInSetColors(val);\n    }\n    return result;\n}\nclass EffectDictionary {\n    constructor(effectMap) {\n        this.effectMap = processEffectMap(effectMap);\n    }\n    toProgramMap(gl, vShader, uniformLocs, fShaders) {\n        const programMap = {};\n        let needs = {\n            neighborSample: false,\n            centerSample: false,\n            sceneBuffer: false,\n            timeUniform: false,\n            mouseUniform: false,\n            passCount: false,\n            extraBuffers: new Set(),\n        };\n        for (const name in this.effectMap) {\n            const effects = this.effectMap[name];\n            // wrap the given list of effects as a loop if need be\n            const effectLoop = new EffectLoop(effects, { num: 1 });\n            if (effectLoop.effects.length === 0) {\n                throw new Error(\"list of effects was empty\");\n            }\n            const programLoop = effectLoop.genPrograms(gl, vShader, uniformLocs, fShaders);\n            // walk the tree to the final program\n            let atBottom = false;\n            let currProgramLoop = programLoop;\n            while (!atBottom) {\n                if (currProgramLoop.programElement instanceof webglprogramloop_1.WebGLProgramLeaf) {\n                    // we traveled right and hit a program, so it must be the last\n                    currProgramLoop.last = true;\n                    atBottom = true;\n                }\n                else {\n                    // set the current program loop to the last in the list\n                    currProgramLoop =\n                        currProgramLoop.programElement[currProgramLoop.programElement.length - 1];\n                }\n            }\n            needs = webglprogramloop_1.updateNeeds(needs, programLoop.getTotalNeeds());\n            programMap[name] = programLoop;\n        }\n        return { programMap, needs };\n    }\n}\nexports.EffectDictionary = EffectDictionary;\n/** effect loop, which can loop over other effects or effect loops */\nclass EffectLoop {\n    constructor(effects, loopInfo) {\n        this.effects = wrapInSetColors(effects);\n        this.loopInfo = loopInfo;\n    }\n    /** @ignore */\n    getSampleNum(mult = 1, sliceStart = 0, sliceEnd = this.effects.length) {\n        mult *= this.loopInfo.num;\n        let acc = 0;\n        const sliced = this.effects.slice(sliceStart, sliceEnd);\n        for (const e of sliced) {\n            acc += e.getSampleNum(mult);\n        }\n        return acc;\n    }\n    /**\n     * @ignore\n     * places effects into loops broken up by sampling effects\n     */\n    regroup() {\n        let sampleCount = 0;\n        /** number of samples in all previous */\n        let prevSampleCount = 0;\n        let prevEffects = [];\n        const regroupedEffects = [];\n        let prevTarget;\n        let currTarget;\n        let mustBreakCounter = 0;\n        const breakOff = () => {\n            mustBreakCounter--;\n            if (prevEffects.length > 0) {\n                // break off all previous effects into their own loop\n                if (prevEffects.length === 1) {\n                    // this is to prevent wrapping in another effect loop\n                    regroupedEffects.push(prevEffects[0]);\n                }\n                else {\n                    regroupedEffects.push(new EffectLoop(prevEffects, { num: 1 }));\n                }\n                sampleCount -= prevSampleCount;\n                prevEffects = [];\n            }\n        };\n        for (const e of this.effects) {\n            const sampleNum = e.getSampleNum();\n            prevSampleCount = sampleCount;\n            sampleCount += sampleNum;\n            if (e instanceof EffectLoop) {\n                currTarget = e.loopInfo.target;\n                if (e.hasTargetSwitch()) {\n                    mustBreakCounter = 2;\n                }\n            }\n            else {\n                // if it's not a loop it's assumed the target is that of outer loop\n                currTarget = this.loopInfo.target;\n            }\n            if (sampleCount > 0 ||\n                currTarget !== prevTarget ||\n                mustBreakCounter > 0) {\n                breakOff();\n            }\n            prevEffects.push(e);\n            prevTarget = currTarget;\n        }\n        // push on all the straggling effects after the grouping is done\n        breakOff();\n        return regroupedEffects;\n    }\n    genPrograms(gl, vShader, uniformLocs, shaders) {\n        // validate\n        const fullSampleNum = this.getSampleNum() / this.loopInfo.num;\n        const firstSampleNum = this.getSampleNum(undefined, 0, 1) / this.loopInfo.num;\n        const restSampleNum = this.getSampleNum(undefined, 1) / this.loopInfo.num;\n        if (!this.hasTargetSwitch() &&\n            (fullSampleNum === 0 || (firstSampleNum === 1 && restSampleNum === 0))) {\n            const codeBuilder = new codebuilder_1.CodeBuilder(this);\n            const program = codeBuilder.compileProgram(gl, vShader, uniformLocs, shaders);\n            return program;\n        }\n        // otherwise, regroup and try again on regrouped loops\n        this.effects = this.regroup();\n        return new webglprogramloop_1.WebGLProgramLoop(this.effects.map((e) => e.genPrograms(gl, vShader, uniformLocs, shaders)), this.loopInfo, gl);\n    }\n    /**\n     * changes the render target of an effect loop (-1 targest the scene texture;\n     * this is used internally)\n     */\n    target(num) {\n        this.loopInfo.target = num;\n        return this;\n    }\n    /** @ignore */\n    hasTargetSwitch() {\n        for (const e of this.effects) {\n            if (e instanceof EffectLoop) {\n                if (e.loopInfo.target !== this.loopInfo.target || e.hasTargetSwitch())\n                    return true;\n            }\n        }\n        return false;\n    }\n    /** @ignore */\n    regionWrap(space, failure, finalPath = true, not) {\n        this.effects = this.effects.map((e, index) => \n        // loops that aren't all the way to the right can't terminate the count ternery\n        // don't wrap fcolors in a ternery (it's redundant)\n        e instanceof EffectLoop\n            ? e.regionWrap(space, failure, index === this.effects.length - 1, not)\n            : new setcolorexpr_1.SetColorExpr(regiondecorator_1.region(space, e.brandExprWithRegion(space), index === this.effects.length - 1 && finalPath\n                ? !(failure instanceof fragcolorexpr_1.FragColorExpr)\n                    ? ternaryexpr_1.ternary(null, failure, fragcolorexpr_1.fcolor())\n                    : failure\n                : fragcolorexpr_1.fcolor(), not)));\n        return this;\n    }\n}\nexports.EffectLoop = EffectLoop;\n/** creates an effect loop */\nfunction loop(effects, rep = 1) {\n    return new EffectLoop(effects, { num: rep });\n}\nexports.loop = loop;\n/** @ignore */\nconst V_SOURCE = `attribute vec2 aPosition;\nvoid main() {\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n}\\n`;\n/** class that can merge effects */\nclass Merger {\n    /**\n     * constructs the object that runs the effects\n     * @param effects list of effects that define the final effect\n     * @param source the source image or texture\n     * @param gl the target rendering context\n     * @param options additional options for the texture\n     */\n    constructor(effects, source, gl, options) {\n        this.uniformLocs = {};\n        /** additional channels */\n        this.channels = [];\n        this.fShaders = [];\n        this.textureMode = source instanceof WebGLTexture;\n        // set channels if provided with channels\n        if ((options === null || options === void 0 ? void 0 : options.channels) !== undefined)\n            this.channels = options === null || options === void 0 ? void 0 : options.channels;\n        if (!(effects instanceof EffectDictionary)) {\n            effects = new EffectDictionary({ default: effects });\n        }\n        // add the copy to scene texture if in texture mode\n        if (this.textureMode) {\n            if (settings_1.settings.verbosity > 1) {\n                console.log(\"we are in texture mode!\");\n            }\n            for (const name in effects.effectMap) {\n                const list = effects.effectMap[name];\n                list.unshift(loop([scenesampleexpr_1.input()]).target(-1));\n            }\n        }\n        this.source = source;\n        this.gl = gl;\n        this.options = options;\n        // set the viewport\n        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n        // set up the vertex buffer\n        const vertexBuffer = this.gl.createBuffer();\n        if (vertexBuffer === null) {\n            throw new Error(\"problem creating vertex buffer\");\n        }\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);\n        const vertexArray = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n        const triangles = new Float32Array(vertexArray);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, triangles, this.gl.STATIC_DRAW);\n        // save the vertex buffer reference just so we can delete it later\n        this.vertexBuffer = vertexBuffer;\n        // compile the simple vertex shader (2 big triangles)\n        const vShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n        if (vShader === null) {\n            throw new Error(\"problem creating the vertex shader\");\n        }\n        // save the vertex shader reference just so we can delete it later\n        this.vShader = vShader;\n        this.gl.shaderSource(vShader, V_SOURCE);\n        this.gl.compileShader(vShader);\n        // make textures\n        this.tex = {\n            // make the front texture the source if we're given a texture instead of\n            // an image\n            back: {\n                name: \"orig_back\",\n                tex: source instanceof WebGLTexture\n                    ? source\n                    : makeTexture(this.gl, this.options),\n            },\n            front: { name: \"orig_front\", tex: makeTexture(this.gl, this.options) },\n            scene: undefined,\n            bufTextures: [],\n        };\n        // create the framebuffer\n        const framebuffer = gl.createFramebuffer();\n        if (framebuffer === null) {\n            throw new Error(\"problem creating the framebuffer\");\n        }\n        this.framebuffer = framebuffer;\n        const { programMap, needs } = effects.toProgramMap(this.gl, this.vShader, this.uniformLocs, this.fShaders);\n        this.programMap = programMap;\n        if (needs.sceneBuffer || this.textureMode) {\n            // we always create a scene texture if we're in texture mode\n            this.tex.scene = {\n                name: \"scene\",\n                tex: makeTexture(this.gl, this.options),\n            };\n        }\n        if (programMap[\"default\"] === undefined) {\n            throw new Error(\"no default program\");\n        }\n        this.programLoop = programMap[\"default\"];\n        // create x amount of empty textures based on buffers needed\n        const channelsNeeded = Math.max(...needs.extraBuffers) + 1;\n        const channelsSupplied = this.channels.length;\n        if (channelsNeeded > channelsSupplied) {\n            throw new Error(\"not enough channels supplied for this effect\");\n        }\n        for (let i = 0; i < this.channels.length; i++) {\n            const texOrImage = this.channels[i];\n            if (!(texOrImage instanceof WebGLTexture)) {\n                // create a new texture; we will update this with the image source every draw\n                const texture = makeTexture(this.gl, this.options);\n                this.tex.bufTextures.push({ name: \"tex_channel_\" + i, tex: texture });\n            }\n            else {\n                // this is already a texture; the user will handle updating this\n                this.tex.bufTextures.push({\n                    name: \"img_channel_\" + i,\n                    tex: texOrImage,\n                });\n            }\n        }\n        if (settings_1.settings.verbosity > 0) {\n            console.log(effects);\n            console.log(this.programMap);\n        }\n    }\n    /**\n     * use the source and channels to draw effect to target context; mouse\n     * position (as with all positions) are stored from the bottom left corner as\n     * this is how texture data is stored\n     * @param timeVal number to set the time uniform to (supply this if you plan to\n     * use [[time]])\n     * @param mouseX the x position of the mouse (supply this if you plan to use\n     * [[mouse]] or [[nmouse]])\n     * @param mouseY the y position of the mouse (supply this if you plan to use\n     * [[mouse]] or [[nmouse]])\n     */\n    draw(timeVal = 0, mouseX = 0, mouseY = 0) {\n        this.gl.activeTexture(this.gl.TEXTURE0 + settings_1.settings.offset);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.back.tex);\n        sendTexture(this.gl, this.source);\n        // TODO only do unbinding and rebinding in texture mode\n        // TODO see if we need to unbind\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        // bind the scene buffer\n        if (this.programLoop.getTotalNeeds().sceneBuffer &&\n            this.tex.scene !== undefined) {\n            this.gl.activeTexture(this.gl.TEXTURE1 + settings_1.settings.offset);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.scene.tex);\n            sendTexture(this.gl, this.source);\n            // TODO see if we need to unbind\n            this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        }\n        // bind the additional buffers\n        let counter = 0;\n        for (const b of this.channels) {\n            // TODO check for texture limit\n            this.gl.activeTexture(this.gl.TEXTURE2 + counter + settings_1.settings.offset);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.bufTextures[counter].tex);\n            sendTexture(this.gl, b);\n            // TODO see if we need to unbind (this gets rid of the error)\n            this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n            counter++;\n        }\n        this.programLoop.run(this.gl, this.tex, this.framebuffer, this.uniformLocs, this.programLoop.last, { timeVal: timeVal, mouseX: mouseX, mouseY: mouseY });\n    }\n    /**\n     * delete all resources created by construction of this [[Merger]]; use right before\n     * intentionally losing a reference to this merger object. this is useful if you want\n     * to construct another [[Merger]] to use new effects\n     */\n    delete() {\n        // TODO do we have to do something with VertexAttribArray?\n        // call bind with null on all textures\n        for (let i = 0; i < 2 + this.tex.bufTextures.length; i++) {\n            // this gets rid of final texture, scene texture and channels\n            this.gl.activeTexture(this.gl.TEXTURE0 + i + settings_1.settings.offset);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        }\n        // call bind with null on all vertex buffers (just 1)\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n        // call bind with null on all frame buffers (just 1)\n        // (this might be redundant because this happens at end of draw call)\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        // delete all programs\n        this.programLoop.delete(this.gl);\n        // delete all textures\n        this.gl.deleteTexture(this.tex.front.tex);\n        this.gl.deleteTexture(this.tex.back.tex);\n        for (const c of this.tex.bufTextures) {\n            this.gl.deleteTexture(c.tex);\n        }\n        // delete all vertex buffers (just 1)\n        this.gl.deleteBuffer(this.vertexBuffer);\n        // delete all frame buffers (just 1)\n        this.gl.deleteFramebuffer(this.framebuffer);\n        // delete all vertex shaders (just 1)\n        this.gl.deleteShader(this.vShader);\n        // delete all fragment shaders\n        for (const f of this.fShaders) {\n            this.gl.deleteShader(f);\n        }\n    }\n    /**\n     * changes the current program loop\n     * @param str key in the program map\n     */\n    changeProgram(str) {\n        if (this.programMap[str] === undefined) {\n            throw new Error(`program \"${str}\" doesn't exist on this merger`);\n        }\n        this.programLoop = this.programMap[str];\n    }\n}\nexports.Merger = Merger;\n/** creates a texture given a context and options */\nfunction makeTexture(gl, options) {\n    const texture = gl.createTexture();\n    if (texture === null) {\n        throw new Error(\"problem creating texture\");\n    }\n    // flip the order of the pixels, or else it displays upside down\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    // bind the texture after creating it\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    const filterMode = (f) => f === undefined || f === \"linear\" ? gl.LINEAR : gl.NEAREST;\n    // how to map texture element\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.minFilterMode));\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.maxFilterMode));\n    if ((options === null || options === void 0 ? void 0 : options.edgeMode) !== \"wrap\") {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    return texture;\n}\nexports.makeTexture = makeTexture;\n/** copies onto texture */\nfunction sendTexture(gl, src) {\n    // if you are using textures instead of images, the user is responsible for\n    // updating that texture, so just return\n    if (src instanceof WebGLTexture || src === null)\n        return;\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);\n}\nexports.sendTexture = sendTexture;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gauss = exports.BlurExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\n/** @ignore */\nfunction genBlurSource(direction, taps) {\n    return {\n        sections: [`gauss${taps}(`, \")\"],\n        values: [direction],\n    };\n}\n/** @ignore */\nfunction tapsToFuncSource(taps) {\n    switch (taps) {\n        case 5:\n            return glslfunctions_1.glslFuncs.gauss5;\n        case 9:\n            return glslfunctions_1.glslFuncs.gauss9;\n        case 13:\n            return glslfunctions_1.glslFuncs.gauss13;\n    }\n}\n/** gaussian blur expression */\nclass BlurExpr extends expr_1.ExprVec4 {\n    constructor(direction, taps = 5, samplerNum) {\n        // this is already guaranteed by typescript, but creates helpful error for\n        // use in gibber or anyone just using javascript\n        if (![5, 9, 13].includes(taps)) {\n            throw new Error(\"taps for gauss blur can only be 5, 9 or 13\");\n        }\n        super(genBlurSource(direction, taps), [\"uDirection\"]);\n        this.direction = direction;\n        this.externalFuncs = [tapsToFuncSource(taps)];\n        this.brandExprWithChannel(0, samplerNum);\n    }\n    /** set the blur direction (keep magnitude no greater than 1 for best effect) */\n    setDirection(direction) {\n        this.setUniform(\"uDirection\" + this.id, direction);\n        this.direction = direction;\n    }\n}\nexports.BlurExpr = BlurExpr;\n/**\n * creates expression that performs one pass of a gaussian blur\n * @param direction direction to blur (keep magnitude less than or equal to 1\n * for best effect)\n * @param taps number of taps (defaults to 5)\n * @param samplerNum which channel to sample from (default 0)\n */\nfunction gauss(direction, taps = 5, samplerNum) {\n    return new BlurExpr(direction, taps, samplerNum);\n}\nexports.gauss = gauss;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pvec4 = exports.pvec3 = exports.pvec2 = exports.vec4 = exports.vec3 = exports.vec2 = void 0;\nconst expr_1 = require(\"./expr\");\n/** @ignore */\nfunction vecSourceList(...components) {\n    const sections = [\"vec\" + components.length + \"(\"];\n    for (let i = 0; i < components.length - 1; i++) {\n        sections.push(\", \");\n    }\n    const defaultNames = [];\n    for (let i = 0; i < components.length; i++) {\n        defaultNames.push(\"uComp\" + i);\n    }\n    sections.push(\")\");\n    return [{ sections: sections, values: components }, defaultNames];\n}\n// expression vector shorthands\n/** creates a basic vec2 expression */\nfunction vec2(comp1, comp2) {\n    return new expr_1.BasicVec2(...vecSourceList(...[comp1, comp2].map((c) => expr_1.wrapInValue(c))));\n}\nexports.vec2 = vec2;\n/** creates a basic vec3 expression */\nfunction vec3(comp1, comp2, comp3) {\n    return new expr_1.BasicVec3(...vecSourceList(...[comp1, comp2, comp3].map((c) => expr_1.wrapInValue(c))));\n}\nexports.vec3 = vec3;\n/** creates a basic vec4 expression */\nfunction vec4(comp1, comp2, comp3, comp4) {\n    return new expr_1.BasicVec4(...vecSourceList(...[comp1, comp2, comp3, comp4].map((c) => expr_1.wrapInValue(c))));\n}\nexports.vec4 = vec4;\n// primitive vector shorthands\n/** creates a primitive vec2 expression */\nfunction pvec2(comp1, comp2) {\n    return new expr_1.PrimitiveVec2([comp1, comp2]);\n}\nexports.pvec2 = pvec2;\n/** creates a primitive vec3 expression */\nfunction pvec3(comp1, comp2, comp3) {\n    return new expr_1.PrimitiveVec3([comp1, comp2, comp3]);\n}\nexports.pvec3 = pvec3;\n/** creates a primitive vec4 expression */\nfunction pvec4(comp1, comp2, comp3, comp4) {\n    return new expr_1.PrimitiveVec4([comp1, comp2, comp3, comp4]);\n}\nexports.pvec4 = pvec4;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pblur = exports.PowerBlurLoop = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst blurexpr_1 = require(\"./blurexpr\");\nconst vecexprs_1 = require(\"./vecexprs\");\nconst expr_1 = require(\"./expr\");\nconst baseLog = (x, y) => Math.log(y) / Math.log(x);\n// TODO consider getting rid of this, as it pretty much never looks good\n/** power blur loop */\nclass PowerBlurLoop extends mergepass_1.EffectLoop {\n    constructor(size) {\n        const side = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(size, 0)));\n        const up = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(0, size)));\n        const reps = Math.ceil(baseLog(2, size));\n        super([side, up], {\n            num: reps + 1,\n        });\n        this.size = size;\n        this.loopInfo.func = (i) => {\n            const distance = this.size / Math.pow(2, i);\n            up.setDirection(vecexprs_1.pvec2(0, distance));\n            side.setDirection(vecexprs_1.pvec2(distance, 0));\n        };\n    }\n    /** sets the size of the radius */\n    setSize(size) {\n        this.size = size;\n        this.loopInfo.num = Math.ceil(baseLog(2, size));\n    }\n}\nexports.PowerBlurLoop = PowerBlurLoop;\n/**\n * fast approximate blur for large blur radius that might look good in some cases\n * @param size the radius of the blur\n */\nfunction pblur(size) {\n    return new PowerBlurLoop(size);\n}\nexports.pblur = pblur;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.blur2d = exports.Blur2dLoop = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst blurexpr_1 = require(\"./blurexpr\");\nconst expr_1 = require(\"./expr\");\nconst vecexprs_1 = require(\"./vecexprs\");\n/** 2D blur loop */\nclass Blur2dLoop extends mergepass_1.EffectLoop {\n    constructor(horizontal = expr_1.float(expr_1.mut(1)), vertical = expr_1.float(expr_1.mut(1)), reps = 2, taps, samplerNum) {\n        const side = blurexpr_1.gauss(vecexprs_1.vec2(horizontal, 0), taps, samplerNum);\n        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, vertical), taps, samplerNum);\n        super([side, up], { num: reps });\n        this.horizontal = horizontal;\n        this.vertical = vertical;\n    }\n    /**\n     * set the horizontal stretch of the blur effect (no greater than 1 for best\n     * effect)\n     */\n    setHorizontal(num) {\n        if (!(this.horizontal instanceof expr_1.BasicFloat))\n            throw new Error(\"horizontal expression not basic float\");\n        this.horizontal.setVal(num);\n    }\n    /**\n     * set the vertical stretch of the blur effect (no greater than 1 for best\n     * effect)\n     */\n    setVertical(num) {\n        if (!(this.vertical instanceof expr_1.BasicFloat))\n            throw new Error(\"vertical expression not basic float\");\n        this.vertical.setVal(num);\n    }\n}\nexports.Blur2dLoop = Blur2dLoop;\n/**\n * creates a loop that runs a horizontal, then vertical gaussian blur (anything\n * more than 1 pixel in the horizontal or vertical direction will create a\n * ghosting effect, which is usually not desirable)\n * @param horizontalExpr float for the horizontal blur (1 pixel default)\n * @param verticalExpr float for the vertical blur (1 pixel default)\n * @param reps how many passes (defaults to 2)\n * @param taps how many taps (defaults to 5)\n * @param samplerNum change if you want to sample from a different channel and\n * the outer loop has a different target\n */\nfunction blur2d(horizontalExpr, verticalExpr, reps, taps, samplerNum) {\n    return new Blur2dLoop(expr_1.wrapInValue(horizontalExpr), expr_1.wrapInValue(verticalExpr), reps, taps, samplerNum);\n}\nexports.blur2d = blur2d;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.len = exports.LenExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** length expression */\nclass LenExpr extends expr_1.ExprFloat {\n    constructor(vec) {\n        super(expr_1.tag `length(${vec})`, [\"uVec\"]);\n        this.vec = vec;\n    }\n    setVec(vec) {\n        this.setUniform(\"uVec\" + this.id, vec);\n        this.vec = vec;\n    }\n}\nexports.LenExpr = LenExpr;\n/** creates an expreession that calculates the length of a vector */\nfunction len(vec) {\n    return new LenExpr(vec);\n}\nexports.len = len;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.norm = exports.NormExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** normalize expression */\nclass NormExpr extends expr_1.Operator {\n    constructor(vec) {\n        super(vec, expr_1.tag `normalize(${vec})`, [\"uVec\"]);\n        this.vec = vec;\n    }\n    /** sets the vec to normalize */\n    setVec(vec) {\n        this.setUniform(\"uVec\" + this.id, vec);\n        this.vec = vec;\n    }\n}\nexports.NormExpr = NormExpr;\n/** creates an expression that normalizes a vector */\nfunction norm(vec) {\n    return new NormExpr(vec);\n}\nexports.norm = norm;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pixel = exports.FragCoordExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** frag coord expression (xy components only) */\nclass FragCoordExpr extends expr_1.ExprVec2 {\n    constructor() {\n        super(expr_1.tag `gl_FragCoord.xy`, []);\n    }\n}\nexports.FragCoordExpr = FragCoordExpr;\n/**\n * creates an expression that evaluates to the frag coord in pixels (samplers\n * take normalized coordinates, so you might want [[nfcoord]] instead)\n */\nfunction pixel() {\n    return new FragCoordExpr();\n}\nexports.pixel = pixel;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.center = exports.NormCenterFragCoordExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** normalized centered frag coord expression */\nclass NormCenterFragCoordExpr extends expr_1.ExprVec2 {\n    constructor() {\n        super(expr_1.tag `(gl_FragCoord.xy / uResolution - 0.5)`, []);\n    }\n}\nexports.NormCenterFragCoordExpr = NormCenterFragCoordExpr;\n/**\n * creates an expression that calculates the normalized centered coord\n * (coordinates range from -0.5 to 0.5)\n */\nfunction center() {\n    return new NormCenterFragCoordExpr();\n}\nexports.center = center;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.brightness = exports.Brightness = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\n/** brightness expression */\nclass Brightness extends expr_1.ExprVec4 {\n    constructor(brightness, col = fragcolorexpr_1.fcolor()) {\n        super(expr_1.tag `brightness(${brightness}, ${col})`, [\"uBrightness\", \"uColor\"]);\n        this.brightness = brightness;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.brightness];\n    }\n    /** set the brightness (should probably be between -1 and 1) */\n    setBrightness(brightness) {\n        this.setUniform(\"uBrightness\" + this.id, brightness);\n        this.brightness = expr_1.wrapInValue(brightness);\n    }\n}\nexports.Brightness = Brightness;\n/**\n * changes the brightness of a color\n * @param val float for how much to change the brightness by (should probably be\n * between -1 and 1)\n * @param col the color to increase the brightness of (defaults to current\n * fragment color)\n */\nfunction brightness(val, col) {\n    return new Brightness(expr_1.wrapInValue(val), col);\n}\nexports.brightness = brightness;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contrast = exports.ContrastExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\nclass ContrastExpr extends expr_1.ExprVec4 {\n    constructor(contrast, col = fragcolorexpr_1.fcolor()) {\n        super(expr_1.tag `contrast(${contrast}, ${col})`, [\"uVal\", \"uCol\"]);\n        this.contrast = contrast;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.contrast];\n    }\n    /** sets the contrast */\n    setContrast(contrast) {\n        this.setUniform(\"uContrast\" + this.id, contrast);\n        this.contrast = expr_1.wrapInValue(contrast);\n    }\n}\nexports.ContrastExpr = ContrastExpr;\n/**\n * changes the contrast of a color\n * @param val float for how much to change the contrast by (should probably be\n * between -1 and 1)\n * @param col the color to increase the contrast of (defaults to current\n * fragment color)\n */\nfunction contrast(val, col) {\n    return new ContrastExpr(expr_1.wrapInValue(val), col);\n}\nexports.contrast = contrast;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.grain = exports.GrainExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\n// TODO consider getting rid of this since it's easy to make your own with\n// `random` and `brightness`\n/** grain expression */\nclass GrainExpr extends expr_1.ExprVec4 {\n    constructor(grain) {\n        super(expr_1.tag `vec4((1.0 - ${grain} * random(gl_FragCoord.xy)) * gl_FragColor.rgb, gl_FragColor.a);`, [\"uGrain\"]);\n        this.grain = grain;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.random];\n        this.needs.centerSample = true;\n    }\n    /** sets the grain level  */\n    setGrain(grain) {\n        this.setUniform(\"uGrain\" + this.id, grain);\n        this.grain = expr_1.wrapInValue(grain);\n    }\n}\nexports.GrainExpr = GrainExpr;\n/**\n * creates an expression that adds random grain\n * @param val how much the grain should impact the image (0 to 1 is reasonable)\n */\nfunction grain(val) {\n    return new GrainExpr(expr_1.wrapInValue(val));\n}\nexports.grain = grain;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.changecomp = exports.ChangeCompExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst getcompexpr_1 = require(\"./getcompexpr\");\n/** @ignore */\nfunction getChangeFunc(typ, id, setter, comps, op = \"\") {\n    return `${typ} changecomp_${id}(${typ} col, ${setter.typeString()} setter) {\n  col.${comps} ${op}= setter;\n  return col;\n}`;\n}\n/**\n * throws a runtime error if component access is not valid, and disallows\n * duplicate components because duplicate components can not be in a left\n * expression. (for example `v.xyx = vec3(1., 2., 3.)` is illegal, but `v1.xyz\n * = v2.xyx` is legal.) also checks for type errors such as `v1.xy = vec3(1.,\n * 2., 3.)`; the right hand side can only be a `vec2` if only two components\n * are supplied\n * @param comps component string\n * @param setter how the components are being changed\n * @param vec the vector where components are being accessed\n */\nfunction checkChangeComponents(comps, setter, vec) {\n    // setter has different length than components\n    if (comps.length !== getcompexpr_1.typeStringToLength(setter.typeString())) {\n        throw new Error(\"components length must be equal to the target float/vec\");\n    }\n    // duplicate components\n    if (duplicateComponents(comps)) {\n        throw new Error(\"duplicate components not allowed on left side\");\n    }\n    // legal components\n    getcompexpr_1.checkLegalComponents(comps, vec);\n}\n/** @ignore */\nfunction duplicateComponents(comps) {\n    return new Set(comps.split(\"\")).size !== comps.length;\n}\n/** change component expression */\nclass ChangeCompExpr extends expr_1.Operator {\n    constructor(vec, setter, comps, op) {\n        checkChangeComponents(comps, setter, vec);\n        // part of name of custom function\n        const operation = op === \"+\"\n            ? \"plus\"\n            : op === \"-\"\n                ? \"minus\"\n                : op === \"*\"\n                    ? \"mult\"\n                    : op === \"/\"\n                        ? \"div\"\n                        : \"assign\";\n        const suffix = `${vec.typeString()}_${setter.typeString()}_${comps}_${operation}`;\n        super(vec, { sections: [`changecomp_${suffix}(`, \", \", \")\"], values: [vec, setter] }, [\"uOriginal\", \"uNew\"]);\n        this.originalVec = vec;\n        this.newVal = setter;\n        this.externalFuncs = [\n            getChangeFunc(vec.typeString(), suffix, setter, comps, op),\n        ];\n    }\n    /** set the original vector */\n    setOriginal(originalVec) {\n        this.setUniform(\"uOriginal\" + this.id, originalVec);\n        this.originalVec = originalVec;\n    }\n    /** set the neww vector */\n    setNew(newVal) {\n        this.setUniform(\"uNew\" + this.id, newVal);\n        this.newVal = expr_1.wrapInValue(newVal);\n    }\n}\nexports.ChangeCompExpr = ChangeCompExpr;\n/**\n * change the components of a vector\n * @param vec the vector to augment components of\n * @param setter the vector (or float, if only one component is changed) for\n * how to change the components\n * @param comps string representing the components to change (e.g. `\"xy\"` or\n * `\"r\"` or `\"stpq\"`.)\n * @param op optionally perform an operation on the original component\n * (defaults to no operation, just assigning that component to a new value)\n */\nfunction changecomp(vec, setter, comps, op) {\n    return new ChangeCompExpr(vec, expr_1.wrapInValue(setter), comps, op);\n}\nexports.changecomp = changecomp;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rgb2hsv = exports.RGBToHSVExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** RGB to HSV expression */\nclass RGBToHSVExpr extends expr_1.ExprVec4 {\n    constructor(color) {\n        super(expr_1.tag `rgb2hsv(${color})`, [\"uRGBCol\"]);\n        this.color = color;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.rgb2hsv];\n    }\n    /** sets the color to convert */\n    setColor(color) {\n        this.setUniform(\"uRGBCol\", color);\n        this.color = color;\n    }\n}\nexports.RGBToHSVExpr = RGBToHSVExpr;\n/**\n * creates an expression that converts a color (with an alpha component) from\n * rgb to hsv\n * @param col the rgba color to convert to hsva\n */\nfunction rgb2hsv(col) {\n    return new RGBToHSVExpr(col);\n}\nexports.rgb2hsv = rgb2hsv;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hsv2rgb = exports.HSVToRGBExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** HSV to RGB expression */\nclass HSVToRGBExpr extends expr_1.ExprVec4 {\n    constructor(color) {\n        super(expr_1.tag `hsv2rgb(${color})`, [\"uHSVCol\"]);\n        this.color = color;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.hsv2rgb];\n    }\n    /** sets the color to convert */\n    setColor(color) {\n        this.setUniform(\"uHSVCol\", color);\n        this.color = color;\n    }\n}\nexports.HSVToRGBExpr = HSVToRGBExpr;\n/**\n * converts a color (with an alpha compoment) from hsv to rgb\n * @param col the hsva color to convert to rgba\n */\nfunction hsv2rgb(col) {\n    return new HSVToRGBExpr(col);\n}\nexports.hsv2rgb = hsv2rgb;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.time = exports.TimeExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** time expression */\nclass TimeExpr extends expr_1.ExprFloat {\n    constructor() {\n        super(expr_1.tag `uTime`, []);\n        this.needs.timeUniform = true;\n    }\n}\nexports.TimeExpr = TimeExpr;\n/** creates a time expression that evaluates to the current time */\nfunction time() {\n    return new TimeExpr();\n}\nexports.time = time;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.a1 = exports.Arity1HomogenousExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** @ignore */\nfunction genArity1SourceList(name, val) {\n    return {\n        sections: [name + \"(\", \")\"],\n        values: [val],\n    };\n}\n/** arity 1 homogenous function expression */\nclass Arity1HomogenousExpr extends expr_1.Operator {\n    constructor(val, operation) {\n        super(val, genArity1SourceList(operation, val), [\"uVal\"]);\n        this.val = val;\n    }\n    /** set the value being passed into the arity 1 homogenous function */\n    setVal(val) {\n        this.setUniform(\"uVal\" + this.id, val);\n        this.val = expr_1.wrapInValue(val);\n    }\n}\nexports.Arity1HomogenousExpr = Arity1HomogenousExpr;\n/**\n * built-in functions that take in one `genType x` and return a `genType x`\n * @param name function name (see [[Arity1HomogenousName]] for valid function names)\n * @param val the `genType x` argument\n */\nfunction a1(name, val) {\n    return new Arity1HomogenousExpr(expr_1.wrapInValue(val), name);\n}\nexports.a1 = a1;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.a2 = exports.Arity2HomogenousExpr = void 0;\nconst expr_1 = require(\"./expr\");\n// note: glsl has atan(y/x) as well as atan(y, x)\n/** @ignore */\nfunction genArity1SourceList(name, val1, val2) {\n    return {\n        sections: [name + \"(\", \",\", \")\"],\n        values: [val1, val2],\n    };\n}\n/** arity 2 homogenous function expression */\nclass Arity2HomogenousExpr extends expr_1.Operator {\n    constructor(name, val1, val2) {\n        super(val1, genArity1SourceList(name, val1, val2), [\"uVal1\", \"uVal2\"]);\n        this.val1 = val1;\n        this.val2 = val2;\n    }\n    /** set the first value being passed into the arity 2 homogenous function */\n    setFirstVal(val1) {\n        this.setUniform(\"uVal1\" + this.id, val1);\n        this.val1 = expr_1.wrapInValue(val1);\n    }\n    /** set the second value being passed into the arity 2 homogenous function */\n    setSecondVal(val2) {\n        this.setUniform(\"uVal2\" + this.id, val2);\n        this.val2 = expr_1.wrapInValue(val2);\n    }\n}\nexports.Arity2HomogenousExpr = Arity2HomogenousExpr;\n// implementation\n/**\n * built-in functions that take in two `genType x` arguments and return a `genType x`\n * @param name function name (see [[Arity2HomogenousName]] for valid function names)\n * @param val1 the first `genType x` argument\n * @param val2 the second `genType x` argument\n */\nfunction a2(name, val1, val2) {\n    return new Arity2HomogenousExpr(name, expr_1.wrapInValue(val1), expr_1.wrapInValue(val2));\n}\nexports.a2 = a2;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fxaa = void 0;\nconst expr_1 = require(\"./expr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** FXAA expression */\nclass FXAAExpr extends expr_1.ExprVec4 {\n    constructor() {\n        super(expr_1.tag `fxaa()`, []);\n        this.externalFuncs = [glslfunctions_1.glslFuncs.fxaa];\n        this.needs.neighborSample = true;\n    }\n}\n/** FXAA antaliasing expression */\nfunction fxaa() {\n    return new FXAAExpr();\n}\nexports.fxaa = fxaa;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.channel = exports.ChannelSampleExpr = void 0;\nconst codebuilder_1 = require(\"../codebuilder\");\nconst expr_1 = require(\"./expr\");\nconst normfragcoordexpr_1 = require(\"./normfragcoordexpr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** @ignore */\nfunction genChannelSampleSource(buf, coord) {\n    return {\n        sections: [\"channel(\", `, ${codebuilder_1.channelSamplerName(buf)})`],\n        values: [coord],\n    };\n}\n// TODO create a way to sample but not clamp by region\n/** channel sample expression */\nclass ChannelSampleExpr extends expr_1.ExprVec4 {\n    constructor(buf, coord = normfragcoordexpr_1.pos()) {\n        super(genChannelSampleSource(buf, coord), [\"uVec\"]);\n        this.coord = coord;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.channel];\n        if (buf !== -1)\n            this.needs.extraBuffers = new Set([buf]);\n        else\n            this.needs.neighborSample = true;\n    }\n    setCoord(coord) {\n        this.setUniform(\"uVec\", coord);\n        this.coord = coord;\n    }\n}\nexports.ChannelSampleExpr = ChannelSampleExpr;\n/**\n * creates an expression that samples from one of the user-defined channels.\n * don't sample from the same channel that you are using [[target]] on in a\n * loop, just use [[fcolor]]\n * @param channel which channel to sample from\n * @param vec where to sample the channel texture (defaults to the normalized\n * frag coord)\n */\nfunction channel(channel, vec) {\n    return new ChannelSampleExpr(channel, vec);\n}\nexports.channel = channel;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gaussian = exports.GaussianExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\n/** gaussian expression */\nclass GaussianExpr extends expr_1.ExprFloat {\n    constructor(x, a, b) {\n        super(expr_1.tag `gaussian(${x}, ${a}, ${b})`, [\"uFloatX\", \"uFloatA\", \"uFloatB\"]);\n        this.x = x;\n        this.a = a;\n        this.b = b;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.gaussian];\n    }\n    setX(x) {\n        this.setUniform(\"uFloatX\" + this.id, x);\n        this.x = expr_1.wrapInValue(x);\n    }\n    setA(a) {\n        this.setUniform(\"uFloatA\" + this.id, a);\n        this.a = expr_1.wrapInValue(a);\n    }\n    setB(b) {\n        this.setUniform(\"uFloatB\" + this.id, b);\n        this.b = expr_1.wrapInValue(b);\n    }\n}\nexports.GaussianExpr = GaussianExpr;\n/**\n * gaussian function that defaults to normal distribution\n * @param x x position in the curve\n * @param a horizontal position of peak (defaults to 0 for normal distribution)\n * @param b horizontal stretch of the curve (defaults to 1 for normal distribution)\n */\nfunction gaussian(x, a = 0, b = 1) {\n    return new GaussianExpr(expr_1.wrapInValue(x), expr_1.wrapInValue(a), expr_1.wrapInValue(b));\n}\nexports.gaussian = gaussian;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dof = exports.DoFLoop = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst arity2_1 = require(\"./arity2\");\nconst blurexpr_1 = require(\"./blurexpr\");\nconst channelsampleexpr_1 = require(\"./channelsampleexpr\");\nconst expr_1 = require(\"./expr\");\nconst gaussianexpr_1 = require(\"./gaussianexpr\");\nconst getcompexpr_1 = require(\"./getcompexpr\");\nconst opexpr_1 = require(\"./opexpr\");\nconst vecexprs_1 = require(\"./vecexprs\");\nclass DoFLoop extends mergepass_1.EffectLoop {\n    constructor(depth = expr_1.mut(expr_1.pfloat(0.3)), rad = expr_1.mut(expr_1.pfloat(0.01)), depthInfo = getcompexpr_1.getcomp(channelsampleexpr_1.channel(0), \"r\"), reps = 2, taps = 13) {\n        let guassianExpr = gaussianexpr_1.gaussian(depthInfo, depth, rad);\n        const side = blurexpr_1.gauss(vecexprs_1.vec2(arity2_1.a2(\"pow\", opexpr_1.op(1, \"-\", guassianExpr), 4), 0), taps);\n        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, arity2_1.a2(\"pow\", opexpr_1.op(1, \"-\", guassianExpr), 4)), taps);\n        super([side, up], { num: reps });\n        this.gaussian = guassianExpr;\n    }\n    setDepth(depth) {\n        // this translates the gaussian curve to the side\n        this.gaussian.setA(depth);\n    }\n    setRadius(radius) {\n        // this scales the gaussian curve to focus on a larger band of depth\n        this.gaussian.setB(radius);\n    }\n}\nexports.DoFLoop = DoFLoop;\n/**\n * creates depth of field expression; all values are mutable by default\n * @param depth float for what inverse depth to focus on (1 on top of the\n * camera; 0 is infinity)\n * @param rad float for how deep the band of in-focus geometry is (a value\n * between 0.01 and 0.1 is reasonable)\n * @param depthInfo float the expression that represents the inverse depth\n * (defaults to sampling the red component from channel 0)\n * @param reps how many times to repeat the gaussian blur\n */\nfunction dof(depth, rad, depthInfo, reps) {\n    return new DoFLoop(expr_1.wrapInValue(depth), expr_1.wrapInValue(rad), expr_1.wrapInValue(depthInfo), reps);\n}\nexports.dof = dof;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.truedepth = exports.TrueDepthExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** true depth expression */\nclass TrueDepthExpr extends expr_1.ExprFloat {\n    constructor(depth) {\n        super(expr_1.tag `truedepth(${depth})`, [\"uDist\"]);\n        this.depth = depth;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.truedepth];\n    }\n    /** sets the distance to convert to the true depth */\n    setDist(depth) {\n        this.setUniform(\"uDist\", depth);\n        this.depth = expr_1.wrapInValue(depth);\n    }\n}\nexports.TrueDepthExpr = TrueDepthExpr;\n/** calculates the linear depth from inverse depth value `1 / distance` */\nfunction truedepth(depth) {\n    return new TrueDepthExpr(expr_1.wrapInValue(depth));\n}\nexports.truedepth = truedepth;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.godrays = exports.GodRaysExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\nconst vecexprs_1 = require(\"./vecexprs\");\n/**\n * @ignore\n * the number of samples in the source code already\n */\nconst DEFAULT_SAMPLES = 100;\n/** godrays expression */\nclass GodRaysExpr extends expr_1.ExprVec4 {\n    // sane godray defaults from https://github.com/Erkaman/glsl-godrays/blob/master/example/index.js\n    constructor(col = fragcolorexpr_1.fcolor(), exposure = expr_1.mut(1.0), decay = expr_1.mut(1.0), density = expr_1.mut(1.0), weight = expr_1.mut(0.01), lightPos = expr_1.mut(vecexprs_1.pvec2(0.5, 0.5)), samplerNum = 0, numSamples = DEFAULT_SAMPLES, convertDepth) {\n        // TODO the metaprogramming here is not so good!\n        // leaving off the function call section for now (we addd it back later)\n        const sourceLists = expr_1.tag `${col}, ${exposure}, ${decay}, ${density}, ${weight}, ${lightPos}, ${convertDepth !== undefined ? convertDepth.threshold : expr_1.float(0)}, ${convertDepth !== undefined ? convertDepth.newColor : vecexprs_1.vec4(0, 0, 0, 0)})`;\n        // TODO make this more generic\n        // append the _<num> onto the function name\n        // also add _depth if this is a version of the function that uses depth buffer\n        const customName = `godrays${convertDepth !== undefined ? \"_depth\" : \"\"}${numSamples !== 100 ? \"_s\" + numSamples : \"\"}(`;\n        sourceLists.sections[0] = customName;\n        super(sourceLists, [\n            \"uCol\",\n            \"uExposure\",\n            \"uDecay\",\n            \"uDensity\",\n            \"uWeight\",\n            \"uLightPos\",\n            \"uThreshold\",\n            \"uNewColor\",\n        ]);\n        this.col = col;\n        this.exposure = exposure;\n        this.decay = decay;\n        this.density = density;\n        this.weight = weight;\n        this.lightPos = lightPos;\n        this.threshold = convertDepth === null || convertDepth === void 0 ? void 0 : convertDepth.threshold;\n        this.newColor = convertDepth === null || convertDepth === void 0 ? void 0 : convertDepth.newColor;\n        // will be 1 if needs to convert depth, and 0 otherwise\n        this.funcIndex = ~~(convertDepth !== undefined);\n        let customGodRayFunc = glslfunctions_1.glslFuncs.godrays\n            .split(\"godrays(\")\n            .join(customName)\n            .replace(`NUM_SAMPLES = ${DEFAULT_SAMPLES}`, \"NUM_SAMPLES = \" + numSamples);\n        if (convertDepth !== undefined) {\n            // with regex, uncomment the line in the source code that does the\n            // conversion (if you think about it that's basically what a preprocessor\n            // does...)\n            customGodRayFunc = customGodRayFunc.replace(/\\/\\/uncomment\\s/g, \"\");\n            this.externalFuncs.push(glslfunctions_1.glslFuncs.depth2occlusion);\n        }\n        this.externalFuncs.push(customGodRayFunc);\n        this.brandExprWithChannel(this.funcIndex, samplerNum);\n    }\n    /** sets the light color */\n    setColor(color) {\n        this.setUniform(\"uCol\" + this.id, color);\n        this.col = color;\n    }\n    /** sets the exposure */\n    setExposure(exposure) {\n        this.setUniform(\"uExposure\" + this.id, exposure);\n        this.exposure = expr_1.wrapInValue(exposure);\n    }\n    /** sets the decay */\n    setDecay(decay) {\n        this.setUniform(\"uDecay\" + this.id, decay);\n        this.decay = expr_1.wrapInValue(decay);\n    }\n    /** sets the density */\n    setDensity(density) {\n        this.setUniform(\"uDensity\" + this.id, density);\n        this.density = expr_1.wrapInValue(density);\n    }\n    /** sets the weight */\n    setWeight(weight) {\n        this.setUniform(\"uWeight\" + this.id, weight);\n        this.weight = expr_1.wrapInValue(weight);\n    }\n    /** sets the light position */\n    setLightPos(lightPos) {\n        this.setUniform(\"uLightPos\" + this.id, lightPos);\n        this.lightPos = lightPos;\n    }\n    // these only matter when you're using a depth buffer and not an occlusion\n    // buffer (although right now, you'll still be able to set them)\n    setThreshold(threshold) {\n        this.setUniform(\"uThreshold\" + this.id, threshold);\n        this.threshold = expr_1.wrapInValue(threshold);\n    }\n    setNewColor(newColor) {\n        this.setUniform(\"uNewColor\" + this.id, newColor);\n        this.newColor = newColor;\n    }\n}\nexports.GodRaysExpr = GodRaysExpr;\n/**\n * create a godrays expression which requires an occlusion map; all values are\n * mutable by default\n * @param options object that defines godrays properties (has sane defaults)\n */\nfunction godrays(options = {}) {\n    return new GodRaysExpr(options.color, expr_1.wrapInValue(options.exposure), expr_1.wrapInValue(options.decay), expr_1.wrapInValue(options.density), expr_1.wrapInValue(options.weight), options.lightPos, options.samplerNum, options.numSamples, options.convertDepth === undefined\n        ? undefined\n        : {\n            threshold: expr_1.wrapInValue(options.convertDepth.threshold),\n            newColor: options.convertDepth.newColor,\n        });\n}\nexports.godrays = godrays;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.depth2occlusion = exports.DepthToOcclusionExpr = void 0;\nconst channelsampleexpr_1 = require(\"./channelsampleexpr\");\nconst expr_1 = require(\"./expr\");\nconst vecexprs_1 = require(\"./vecexprs\");\n/** depth info to occlussion info expression */\nclass DepthToOcclusionExpr extends expr_1.ExprVec4 {\n    constructor(depthCol = channelsampleexpr_1.channel(0), newCol = expr_1.mut(vecexprs_1.pvec4(1, 1, 1, 1)), threshold = expr_1.mut(expr_1.pfloat(0.01))) {\n        super(expr_1.tag `depth2occlusion(${depthCol}, ${newCol}, ${threshold})`, [\n            \"uDepth\",\n            \"uNewCol\",\n            \"uThreshold\",\n        ]);\n        this.depthCol = depthCol;\n        this.newCol = newCol;\n        this.threshold = threshold;\n    }\n    setDepthColor(depthCol) {\n        this.setUniform(\"uDepth\" + this.id, depthCol);\n        this.depthCol = depthCol;\n    }\n    setNewColor(newCol) {\n        this.setUniform(\"uNewCol\" + this.id, newCol);\n        this.newCol = newCol;\n    }\n    setThreshold(threshold) {\n        this.setUniform(\"uThreshold\" + this.id, threshold);\n        this.threshold = expr_1.wrapInValue(threshold);\n    }\n}\nexports.DepthToOcclusionExpr = DepthToOcclusionExpr;\n/**\n * converts a `1 / distance` depth texture to an occlusion texture, with all\n * occluded geometry being rendered as black\n * @param depthCol the color representing the inverse depth (defaults to\n * sampling from channel 0)\n * @param newCol the color to replace unoccluded areas by (defaults to white\n * and is mutable by default)\n * @param threshold values below this are not occluded (set to something low,\n * like 0.1 or lower; defaults to 0.01 and is mutable by default)\n */\nfunction depth2occlusion(depthCol, newCol, threshold) {\n    return new DepthToOcclusionExpr(depthCol, newCol, expr_1.wrapInValue(threshold));\n}\nexports.depth2occlusion = depth2occlusion;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolution = exports.ResolutionExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** resolution expression */\nclass ResolutionExpr extends expr_1.ExprVec2 {\n    constructor() {\n        super(expr_1.tag `uResolution`, []);\n    }\n}\nexports.ResolutionExpr = ResolutionExpr;\n/** creates an expression that evaluates to a vector representing the resolution */\nfunction resolution() {\n    return new ResolutionExpr();\n}\nexports.resolution = resolution;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mouse = exports.MouseExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** mouse position expression */\nclass MouseExpr extends expr_1.ExprVec2 {\n    constructor() {\n        super(expr_1.tag `uMouse`, []);\n        this.needs.mouseUniform = true;\n    }\n}\nexports.MouseExpr = MouseExpr;\n/**\n * creates an expression that evaluates to a vector representing the mouse\n * position in pixels\n */\nfunction mouse() {\n    return new MouseExpr();\n}\nexports.mouse = mouse;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rotate = exports.RotateExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\n/** rotate expression */\nclass RotateExpr extends expr_1.ExprVec2 {\n    constructor(vec, angle) {\n        super(expr_1.tag `rotate2d(${vec}, ${angle})`, [\"uVec\", \"uAngle\"]);\n        this.vec = vec;\n        this.angle = angle;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.rotate2d];\n    }\n    /** set the vector to rotate */\n    setVec(vec) {\n        this.setUniform(\"uVec\" + this.id, vec);\n        this.vec = vec;\n    }\n    /** set the angle to rotate by */\n    setAngle(angle) {\n        this.setUniform(\"uAngle\" + this.id, angle);\n        this.angle = expr_1.wrapInValue(angle);\n    }\n}\nexports.RotateExpr = RotateExpr;\n/**\n * creates an expression that rotates a vector by a given angle\n * @param vec the vector to rotate\n * @param angle radians to rotate vector by\n */\nfunction rotate(vec, angle) {\n    return new RotateExpr(vec, expr_1.wrapInValue(angle));\n}\nexports.rotate = rotate;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translate = exports.TranslateExpr = void 0;\nconst expr_1 = require(\"./expr\");\n// really just adding two vecs together, but it might be confusing that there's\n// rotate but no translate, so this is included. also it could make some\n// operations more readable\n/** sets the translate expression */\nclass TranslateExpr extends expr_1.ExprVec2 {\n    constructor(vec, pos) {\n        super(expr_1.tag `(${vec} + ${pos})`, [\"uVec\", \"uPos\"]);\n        this.vec = vec;\n        this.pos = pos;\n    }\n    /** sets the starting position */\n    setVec(vec) {\n        this.setUniform(\"uVec\" + this.id, vec);\n        this.vec = vec;\n    }\n    /** sets how far the vector will be translated */\n    setPos(pos) {\n        this.setUniform(\"uPos\" + this.id, pos);\n        this.pos = pos;\n    }\n}\nexports.TranslateExpr = TranslateExpr;\n/** translates the position of a vector by another vector */\nfunction translate(vec, pos) {\n    return new TranslateExpr(vec, pos);\n}\nexports.translate = translate;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nmouse = exports.NormMouseExpr = void 0;\nconst expr_1 = require(\"./expr\");\n/** normalized mouse position expression */\nclass NormMouseExpr extends expr_1.ExprVec2 {\n    constructor() {\n        super(expr_1.tag `(uMouse / uResolution.xy)`, []);\n        this.needs.mouseUniform = true;\n    }\n}\nexports.NormMouseExpr = NormMouseExpr;\n/**\n * creates an expression that calculates the normalized mouse position\n * (coordinates range from 0 to 1)\n */\nfunction nmouse() {\n    return new NormMouseExpr();\n}\nexports.nmouse = nmouse;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fractalize = exports.perlin = exports.PerlinExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\nconst opexpr_1 = require(\"./opexpr\");\n/** Perlin noise expression */\nclass PerlinExpr extends expr_1.ExprFloat {\n    // TODO include a default\n    constructor(pos) {\n        super(expr_1.tag `gradientnoise(${pos})`, [\"uPos\"]);\n        this.pos = pos;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.random2, glslfunctions_1.glslFuncs.gradientnoise];\n    }\n    /** sets the position to calculate noise value of */\n    setPos(pos) {\n        this.setUniform(\"uPos\", pos);\n        this.pos = pos;\n    }\n}\nexports.PerlinExpr = PerlinExpr;\n/**\n * creates a perlin noise expression; values range from -1 to 1 but they tend\n * to be grayer than the [[simplex]] implementation\n * @param pos position\n */\nfunction perlin(pos) {\n    return new PerlinExpr(pos);\n}\nexports.perlin = perlin;\n/**\n * take any function from a position to a float, and repeatedly sum calls to it\n * with doubling frequency and halving amplitude (works well with [[simplex]]\n * and [[perlin]])\n * @param pos position\n * @param octaves how many layers deep to make the fractal\n * @param func the function to fractalize\n */\nfunction fractalize(pos, octaves, func) {\n    if (octaves < 0)\n        throw new Error(\"octaves can't be < 0\");\n    const recurse = (pos, size, level) => {\n        if (level <= 0)\n            return expr_1.pfloat(0);\n        return opexpr_1.op(func(opexpr_1.op(pos, \"/\", size * 2)), \"+\", recurse(pos, size / 2, level - 1));\n    };\n    return recurse(pos, 0.5, octaves);\n}\nexports.fractalize = fractalize;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.simplex = exports.SimplexNoise = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\n/** simplex noise expression */\nclass SimplexNoise extends expr_1.ExprFloat {\n    constructor(pos) {\n        super(expr_1.tag `simplexnoise(${pos})`, [\"uPos\"]);\n        this.pos = pos;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.simplexhelpers, glslfunctions_1.glslFuncs.simplexnoise];\n    }\n    setPos(pos) {\n        this.setUniform(\"uPos\", pos);\n        this.pos = pos;\n    }\n}\nexports.SimplexNoise = SimplexNoise;\n/**\n * creates a simplex noise expression; values range from -1 to 1\n * @param pos position\n */\nfunction simplex(pos) {\n    return new SimplexNoise(pos);\n}\nexports.simplex = simplex;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.motionblur = exports.MotionBlurLoop = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst channelsampleexpr_1 = require(\"./channelsampleexpr\");\nconst expr_1 = require(\"./expr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\nconst opexpr_1 = require(\"./opexpr\");\n/** frame averaging motion blur loop */\nclass MotionBlurLoop extends mergepass_1.EffectLoop {\n    constructor(target = 0, persistence = expr_1.float(expr_1.mut(0.3))) {\n        const col1 = opexpr_1.op(channelsampleexpr_1.channel(target), \"*\", persistence);\n        const col2 = opexpr_1.op(fragcolorexpr_1.fcolor(), \"*\", opexpr_1.op(1, \"-\", persistence));\n        const effects = [\n            mergepass_1.loop([opexpr_1.op(col1, \"+\", col2)]).target(target),\n            channelsampleexpr_1.channel(target),\n        ];\n        super(effects, { num: 1 });\n        this.persistence = persistence;\n    }\n    /** set the persistence (keep between 0 and 1) */\n    setPersistence(float) {\n        if (!(this.persistence instanceof expr_1.BasicFloat))\n            throw new Error(\"persistence expression not basic float\");\n        this.persistence.setVal(float);\n    }\n}\nexports.MotionBlurLoop = MotionBlurLoop;\n/**\n * creates a frame averaging motion blur effect\n * @param target the channel where your accumulation buffer is (defaults to 0,\n * which you might be using for something like the depth texture, so be sure to\n * change this to suit your needs)\n * @param persistence close to 0 is more ghostly, and close to 1 is nearly no\n * motion blur at all (defaults to 0.3)\n */\nfunction motionblur(target, persistence) {\n    return new MotionBlurLoop(target, expr_1.wrapInValue(persistence));\n}\nexports.motionblur = motionblur;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.random = exports.RandomExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\nconst normfragcoordexpr_1 = require(\"./normfragcoordexpr\");\n/** psuedorandom number expression */\nclass RandomExpr extends expr_1.ExprFloat {\n    constructor(seed = normfragcoordexpr_1.pos()) {\n        super(expr_1.tag `random(${seed})`, [\"uSeed\"]);\n        this.seed = seed;\n        this.externalFuncs = [glslfunctions_1.glslFuncs.random];\n    }\n    /** sets the seed (vary this over time to get a moving effect) */\n    setSeed(seed) {\n        this.setUniform(\"uSeed\", seed);\n        this.seed = seed;\n    }\n}\nexports.RandomExpr = RandomExpr;\n/**\n * creates expression that evaluates to a pseudorandom number between 0 and 1\n * @param seed vec2 to to seed the random number (defaults to the normalized\n * frag coord)\n */\nfunction random(seed) {\n    return new RandomExpr(seed);\n}\nexports.random = random;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sobel = exports.SobelExpr = void 0;\nconst glslfunctions_1 = require(\"../glslfunctions\");\nconst expr_1 = require(\"./expr\");\n/** Sobel edge detection expression */\nclass SobelExpr extends expr_1.ExprVec4 {\n    constructor(samplerNum) {\n        super(expr_1.tag `sobel()`, []);\n        this.externalFuncs = [glslfunctions_1.glslFuncs.sobel];\n        this.brandExprWithChannel(0, samplerNum);\n    }\n}\nexports.SobelExpr = SobelExpr;\n/**\n * creates a Sobel edge detection expression that outputs the raw result; for\n * more highly processed edge detection expressions, see [[edgecolor]] or\n * [[edge]]\n * @param samplerNum where to sample from\n */\nfunction sobel(samplerNum) {\n    return new SobelExpr(samplerNum);\n}\nexports.sobel = sobel;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bloom = exports.BloomLoop = void 0;\nconst mergepass_1 = require(\"../mergepass\");\nconst arity2_1 = require(\"./arity2\");\nconst blurexpr_1 = require(\"./blurexpr\");\nconst brightnessexpr_1 = require(\"./brightnessexpr\");\nconst channelsampleexpr_1 = require(\"./channelsampleexpr\");\nconst contrastexpr_1 = require(\"./contrastexpr\");\nconst expr_1 = require(\"./expr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\nconst opexpr_1 = require(\"./opexpr\");\nconst vecexprs_1 = require(\"./vecexprs\");\n// TODO bloom uses `input` so it has to be the first\n// TODO maybe a way to update the scene buffer?\n/** bloom loop */\nclass BloomLoop extends mergepass_1.EffectLoop {\n    constructor(threshold = expr_1.float(expr_1.mut(0.4)), horizontal = expr_1.float(expr_1.mut(1)), vertical = expr_1.float(expr_1.mut(1)), boost = expr_1.float(expr_1.mut(1.3)), samplerNum = 1, taps = 9, reps = 3) {\n        const bright = expr_1.cfloat(expr_1.tag `((${channelsampleexpr_1.channel(samplerNum)}.r + ${channelsampleexpr_1.channel(samplerNum)}.g + ${channelsampleexpr_1.channel(samplerNum)}.b) / 3.)`);\n        const step = arity2_1.a2(\"step\", bright, threshold);\n        const col = expr_1.cvec4(expr_1.tag `vec4(${channelsampleexpr_1.channel(samplerNum)}.rgb * (1. - ${step}), 1.)`);\n        const list = [\n            mergepass_1.loop([col]).target(samplerNum),\n            mergepass_1.loop([\n                blurexpr_1.gauss(vecexprs_1.vec2(horizontal, 0), taps),\n                blurexpr_1.gauss(vecexprs_1.vec2(0, vertical), taps),\n                brightnessexpr_1.brightness(0.1),\n                contrastexpr_1.contrast(boost),\n            ], reps).target(samplerNum),\n            opexpr_1.op(fragcolorexpr_1.fcolor(), \"+\", channelsampleexpr_1.channel(samplerNum)),\n        ];\n        super(list, { num: 1 });\n        this.threshold = threshold;\n        this.horizontal = horizontal;\n        this.vertical = vertical;\n        this.boost = boost;\n    }\n    /**\n     * set the horizontal stretch of the blur effect (no greater than 1 for best\n     * effect)\n     */\n    setHorizontal(num) {\n        if (!(this.horizontal instanceof expr_1.BasicFloat))\n            throw new Error(\"horizontal expression not basic float\");\n        this.horizontal.setVal(num);\n    }\n    /**\n     * set the vertical stretch of the blur effect (no greater than 1 for best\n     * effect)\n     */\n    setVertical(num) {\n        if (!(this.vertical instanceof expr_1.BasicFloat))\n            throw new Error(\"vertical expression not basic float\");\n        this.vertical.setVal(num);\n    }\n    /** set the treshold */\n    setThreshold(num) {\n        if (!(this.threshold instanceof expr_1.BasicFloat))\n            throw new Error(\"threshold expression not basic float\");\n        this.threshold.setVal(num);\n    }\n    /** set the contrast boost */\n    setBoost(num) {\n        if (!(this.boost instanceof expr_1.BasicFloat))\n            throw new Error(\"boost expression not basic float\");\n        this.boost.setVal(num);\n    }\n}\nexports.BloomLoop = BloomLoop;\n/**\n * creates a bloom loop\n * @param threshold values below this brightness don't get blurred (0.4 is\n * about reasonable, which is also the default)\n * @param horizontal how much to blur vertically (defaults to 1 pixel)\n * @param vertical how much to blur horizontally (defaults to 1 pixel)\n * @param taps how many taps for the blur (defaults to 9)\n * @param reps how many times to loop the blur (defaults to 3)\n */\nfunction bloom(threshold, horizontal, vertical, boost, samplerNum, taps, reps) {\n    return new BloomLoop(expr_1.wrapInValue(threshold), expr_1.wrapInValue(horizontal), expr_1.wrapInValue(vertical), expr_1.wrapInValue(boost), samplerNum, taps, reps);\n}\nexports.bloom = bloom;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monochrome = exports.MonochromeExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** monochrome expression */\nclass MonochromeExpr extends expr_1.ExprVec4 {\n    constructor(color) {\n        super(expr_1.tag `monochrome(${color})`, [\"uColor\"]);\n        this.externalFuncs = [glslfunctions_1.glslFuncs.monochrome];\n        this.color = color;\n    }\n    /** sets the color */\n    setColor(color) {\n        this.setUniform(\"uColor\", color);\n        this.color = color;\n    }\n}\nexports.MonochromeExpr = MonochromeExpr;\n/**\n * creates an expression that converts a color into grayscale, keeping the\n * original alpha\n */\nfunction monochrome(col) {\n    return new MonochromeExpr(col);\n}\nexports.monochrome = monochrome;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.invert = exports.InvertExpr = void 0;\nconst expr_1 = require(\"./expr\");\nconst glslfunctions_1 = require(\"../glslfunctions\");\n/** invert expression */\nclass InvertExpr extends expr_1.ExprVec4 {\n    constructor(color) {\n        super(expr_1.tag `invert(${color})`, [\"uColor\"]);\n        this.externalFuncs = [glslfunctions_1.glslFuncs.invert];\n        this.color = color;\n    }\n    /** sets the color */\n    setColor(color) {\n        this.setUniform(\"uColor\", color);\n        this.color = color;\n    }\n}\nexports.InvertExpr = InvertExpr;\n/**\n * creates an expression that inverts the color, keeping the original alpha\n */\nfunction invert(col) {\n    return new InvertExpr(col);\n}\nexports.invert = invert;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edge = exports.EdgeExpr = void 0;\nconst brightnessexpr_1 = require(\"./brightnessexpr\");\nconst expr_1 = require(\"./expr\");\nconst getcompexpr_1 = require(\"./getcompexpr\");\nconst invertexpr_1 = require(\"./invertexpr\");\nconst monochromeexpr_1 = require(\"./monochromeexpr\");\nconst opexpr_1 = require(\"./opexpr\");\nconst sobelexpr_1 = require(\"./sobelexpr\");\nclass EdgeExpr extends expr_1.WrappedExpr {\n    constructor(mult = expr_1.mut(-1.0), samplerNum) {\n        const operator = opexpr_1.op(getcompexpr_1.getcomp(invertexpr_1.invert(monochromeexpr_1.monochrome(sobelexpr_1.sobel(samplerNum))), \"r\"), \"*\", mult);\n        super(brightnessexpr_1.brightness(operator));\n        this.mult = mult;\n        this.operator = operator;\n    }\n    setMult(mult) {\n        this.operator.setRight(mult);\n        this.mult = expr_1.wrapInValue(mult);\n    }\n}\nexports.EdgeExpr = EdgeExpr;\n/**\n * returns an expression highlights edges where they appear\n * @param style `\"dark\"` for dark edges and `\"light\"` for light edges, or a\n * custom number or expression (between -1 and 1) for a more gray style of edge\n * @param samplerNum where to sample from\n */\nfunction edge(style, samplerNum) {\n    const mult = style === \"dark\" ? -1 : style === \"light\" ? 1 : style;\n    return new EdgeExpr(expr_1.wrapInValue(mult), samplerNum);\n}\nexports.edge = edge;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edgecolor = exports.EdgeColorExpr = void 0;\nconst arity2_1 = require(\"./arity2\");\nconst expr_1 = require(\"./expr\");\nconst fragcolorexpr_1 = require(\"./fragcolorexpr\");\nconst monochromeexpr_1 = require(\"./monochromeexpr\");\nconst sobelexpr_1 = require(\"./sobelexpr\");\nconst vecexprs_1 = require(\"./vecexprs\");\n/** edge color expression */\nclass EdgeColorExpr extends expr_1.WrappedExpr {\n    constructor(color, samplerNum, stepped = true) {\n        const expr = stepped\n            ? expr_1.cvec4(expr_1.tag `mix(${color}, ${fragcolorexpr_1.fcolor()}, ${monochromeexpr_1.monochrome(arity2_1.a2(\"step\", vecexprs_1.vec4(0.5, 0.5, 0.5, 0.0), sobelexpr_1.sobel(samplerNum)))})`)\n            : expr_1.cvec4(expr_1.tag `mix(${color}, ${fragcolorexpr_1.fcolor()}, ${monochromeexpr_1.monochrome(sobelexpr_1.sobel(samplerNum))})`);\n        super(expr);\n        this.color = color;\n        this.expr = expr;\n    }\n    setColor(color) {\n        this.expr.setUniform(\"uCustomName0\" + this.expr.id, color);\n        this.color = color;\n    }\n}\nexports.EdgeColorExpr = EdgeColorExpr;\n/**\n * creates a colored edge detection expression\n * @param color what color to make the edge\n * @param samplerNum where to sample from\n * @param stepped whether to round the result of sobel edge detection (defaults\n * to true)\n */\nfunction edgecolor(color, samplerNum, stepped) {\n    return new EdgeColorExpr(color, samplerNum, stepped);\n}\nexports.edgecolor = edgecolor;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./mergepass\"), exports);\n__exportStar(require(\"./exprtypes\"), exports);\n__exportStar(require(\"./glslfunctions\"), exports);\n__exportStar(require(\"./settings\"), exports);\n__exportStar(require(\"./exprs/blurexpr\"), exports);\n__exportStar(require(\"./exprs/fragcolorexpr\"), exports);\n__exportStar(require(\"./exprs/vecexprs\"), exports);\n__exportStar(require(\"./exprs/opexpr\"), exports);\n__exportStar(require(\"./exprs/powerblur\"), exports);\n__exportStar(require(\"./exprs/blur2dloop\"), exports);\n__exportStar(require(\"./exprs/lenexpr\"), exports);\n__exportStar(require(\"./exprs/normexpr\"), exports);\n__exportStar(require(\"./exprs/fragcoordexpr\"), exports);\n__exportStar(require(\"./exprs/normfragcoordexpr\"), exports);\n__exportStar(require(\"./exprs/normcenterfragcoordexpr\"), exports);\n__exportStar(require(\"./exprs/scenesampleexpr\"), exports);\n__exportStar(require(\"./exprs/brightnessexpr\"), exports);\n__exportStar(require(\"./exprs/contrastexpr\"), exports);\n__exportStar(require(\"./exprs/grainexpr\"), exports);\n__exportStar(require(\"./exprs/getcompexpr\"), exports);\n__exportStar(require(\"./exprs/changecompexpr\"), exports);\n__exportStar(require(\"./exprs/rgbtohsvexpr\"), exports);\n__exportStar(require(\"./exprs/hsvtorgbexpr\"), exports);\n__exportStar(require(\"./exprs/timeexpr\"), exports);\n__exportStar(require(\"./exprs/arity1\"), exports);\n__exportStar(require(\"./exprs/arity2\"), exports);\n__exportStar(require(\"./exprs/fxaaexpr\"), exports);\n__exportStar(require(\"./exprs/channelsampleexpr\"), exports);\n__exportStar(require(\"./exprs/dofloop\"), exports);\n__exportStar(require(\"./exprs/truedepthexpr\"), exports);\n__exportStar(require(\"./exprs/godraysexpr\"), exports);\n__exportStar(require(\"./exprs/depthtoocclusionexpr\"), exports);\n__exportStar(require(\"./exprs/resolutionexpr\"), exports);\n__exportStar(require(\"./exprs/mouseexpr\"), exports);\n__exportStar(require(\"./exprs/rotateexpr\"), exports);\n__exportStar(require(\"./exprs/translateexpr\"), exports);\n__exportStar(require(\"./exprs/normmouseexpr\"), exports);\n__exportStar(require(\"./exprs/perlinexpr\"), exports);\n__exportStar(require(\"./exprs/simplexexpr\"), exports);\n__exportStar(require(\"./exprs/motionblurloop\"), exports);\n__exportStar(require(\"./exprs/randomexpr\"), exports);\n__exportStar(require(\"./exprs/sobelexpr\"), exports);\n__exportStar(require(\"./exprs/bloomloop\"), exports);\n__exportStar(require(\"./exprs/monochromeexpr\"), exports);\n__exportStar(require(\"./exprs/invertexpr\"), exports);\n__exportStar(require(\"./exprs/edgeexpr\"), exports);\n__exportStar(require(\"./exprs/edgecolorexpr\"), exports);\n__exportStar(require(\"./exprs/ternaryexpr\"), exports);\n__exportStar(require(\"./exprs/regiondecorator\"), exports);\n__exportStar(require(\"./exprs/expr\"), exports);\n"],
  "mappings": "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",
  "names": ["op", "brightness", "contrast", "grain", "channel", "pos", "exports"]
}
