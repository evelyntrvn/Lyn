var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@bandaloo/merge-pass/dist/settings.js
var require_settings = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.settings = void 0;
    exports.settings = {
      /**
       * set to 1 if you want reasonable logging for debugging, such as the
       * generated GLSL code and program tree. set to 100 if you want texture debug
       * info (you probably don't want to do this, as it logs many lines every
       * frame!)
       */
      verbosity: 0,
      /** texture offset */
      offset: 0
    };
  }
});

// node_modules/@bandaloo/merge-pass/dist/webglprogramloop.js
var require_webglprogramloop = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/webglprogramloop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebGLProgramLoop = exports.WebGLProgramLeaf = exports.updateNeeds = void 0;
    var settings_1 = require_settings();
    function updateNeeds(acc, curr) {
      return {
        neighborSample: acc.neighborSample || curr.neighborSample,
        centerSample: acc.centerSample || curr.centerSample,
        sceneBuffer: acc.sceneBuffer || curr.sceneBuffer,
        timeUniform: acc.timeUniform || curr.timeUniform,
        mouseUniform: acc.mouseUniform || curr.mouseUniform,
        passCount: acc.passCount || curr.passCount,
        extraBuffers: /* @__PURE__ */ new Set([...acc.extraBuffers, ...curr.extraBuffers])
      };
    }
    exports.updateNeeds = updateNeeds;
    var WebGLProgramLeaf = class {
      constructor(program, totalNeeds, effects) {
        this.program = program;
        this.totalNeeds = totalNeeds;
        this.effects = effects;
      }
    };
    exports.WebGLProgramLeaf = WebGLProgramLeaf;
    function getLoc(programElement, gl, name) {
      gl.useProgram(programElement.program);
      const loc = gl.getUniformLocation(programElement.program, name);
      if (loc === null) {
        throw new Error("could not get the " + name + " uniform location");
      }
      return loc;
    }
    var WebGLProgramLoop = class {
      constructor(programElement, loopInfo, gl) {
        this.last = false;
        this.counter = 0;
        this.programElement = programElement;
        this.loopInfo = loopInfo;
        if (this.programElement instanceof WebGLProgramLeaf) {
          if (gl === void 0) {
            throw new Error("program element is a program but context is undefined");
          }
          if (this.programElement.totalNeeds.timeUniform) {
            this.timeLoc = getLoc(this.programElement, gl, "uTime");
          }
          if (this.programElement.totalNeeds.mouseUniform) {
            this.mouseLoc = getLoc(this.programElement, gl, "uMouse");
          }
          if (this.programElement.totalNeeds.passCount) {
            this.countLoc = getLoc(this.programElement, gl, "uCount");
          }
        }
      }
      /** get all needs from all programs */
      getTotalNeeds() {
        if (!(this.programElement instanceof WebGLProgramLeaf)) {
          const allNeeds = [];
          for (const p of this.programElement) {
            allNeeds.push(p.getTotalNeeds());
          }
          return allNeeds.reduce(updateNeeds);
        }
        return this.programElement.totalNeeds;
      }
      /**
       * recursively uses all programs in the loop, binding the appropriate
       * textures and setting the appropriate uniforms; the user should only have
       * to call [[draw]] on [[Merger]] and never this function directly
       */
      run(gl, tex, framebuffer, uniformLocs, last, defaultUniforms, outerLoop) {
        let savedTexture;
        if (this.loopInfo.target !== void 0 && // if there is a target switch:
        (outerLoop === null || outerLoop === void 0 ? void 0 : outerLoop.loopInfo.target) !== this.loopInfo.target) {
          savedTexture = tex.back;
          if (this.loopInfo.target !== -1) {
            tex.back = tex.bufTextures[this.loopInfo.target];
          } else {
            if (tex.scene === void 0) {
              throw new Error("tried to target -1 but scene texture was undefined");
            }
            tex.back = tex.scene;
          }
          tex.bufTextures[this.loopInfo.target] = savedTexture;
          if (settings_1.settings.verbosity > 99)
            console.log("saved texture: " + savedTexture.name);
        }
        if (this.programElement instanceof WebGLProgramLeaf) {
          if (this.programElement.totalNeeds.sceneBuffer) {
            if (tex.scene === void 0) {
              throw new Error("needs scene buffer, but scene texture is somehow undefined");
            }
            gl.activeTexture(gl.TEXTURE1 + settings_1.settings.offset);
            if (this.loopInfo.target === -1) {
              gl.bindTexture(gl.TEXTURE_2D, savedTexture.tex);
            } else {
              gl.bindTexture(gl.TEXTURE_2D, tex.scene.tex);
            }
          }
          for (const n of this.programElement.totalNeeds.extraBuffers) {
            gl.activeTexture(gl.TEXTURE2 + n + settings_1.settings.offset);
            gl.bindTexture(gl.TEXTURE_2D, tex.bufTextures[n].tex);
          }
          gl.useProgram(this.programElement.program);
          for (const effect of this.programElement.effects) {
            effect.applyUniforms(gl, uniformLocs);
          }
          if (this.programElement.totalNeeds.timeUniform) {
            if (this.timeLoc === void 0 || defaultUniforms.timeVal === void 0) {
              throw new Error("time or location is undefined");
            }
            gl.uniform1f(this.timeLoc, defaultUniforms.timeVal);
          }
          if (this.programElement.totalNeeds.mouseUniform) {
            if (this.mouseLoc === void 0 || defaultUniforms.mouseX === void 0 || defaultUniforms.mouseY === void 0) {
              throw new Error("mouse uniform or location is undefined");
            }
            gl.uniform2f(this.mouseLoc, defaultUniforms.mouseX, defaultUniforms.mouseY);
          }
          if (this.programElement.totalNeeds.passCount && outerLoop !== void 0) {
            if (this.countLoc === void 0) {
              throw new Error("count location is undefined");
            }
            if (outerLoop !== void 0) {
              gl.uniform1i(this.countLoc, outerLoop.counter);
            }
            this.counter++;
            const mod = outerLoop === void 0 ? 1 : outerLoop.loopInfo.num;
            this.counter %= mod;
          }
        }
        for (let i = 0; i < this.loopInfo.num; i++) {
          const newLast = i === this.loopInfo.num - 1;
          if (this.programElement instanceof WebGLProgramLeaf) {
            if (newLast && last && this.last) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex.front.tex, 0);
            }
            gl.activeTexture(gl.TEXTURE0 + settings_1.settings.offset);
            gl.bindTexture(gl.TEXTURE_2D, tex.back.tex);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            if (settings_1.settings.verbosity > 99) {
              console.log("intermediate back", tex.back.name);
              console.log("intermediate front", tex.front.name);
            }
            [tex.back, tex.front] = [tex.front, tex.back];
            for (const n of this.programElement.totalNeeds.extraBuffers) {
              gl.activeTexture(gl.TEXTURE2 + n + settings_1.settings.offset);
              gl.bindTexture(gl.TEXTURE_2D, null);
            }
            gl.activeTexture(gl.TEXTURE1 + settings_1.settings.offset);
            gl.bindTexture(gl.TEXTURE_2D, null);
          } else {
            if (this.loopInfo.func !== void 0) {
              this.loopInfo.func(i);
            }
            for (const p of this.programElement) {
              p.run(
                gl,
                tex,
                framebuffer,
                uniformLocs,
                newLast,
                defaultUniforms,
                this
                // this is now the outer loop
              );
            }
          }
        }
        if (savedTexture !== void 0) {
          const target = this.loopInfo.target;
          if (settings_1.settings.verbosity > 99) {
            console.log("pre final back", tex.back.name);
            console.log("pre final front", tex.front.name);
          }
          if (this.loopInfo.target !== -1) {
            tex.bufTextures[target] = tex.back;
          } else {
            if (tex.scene === void 0) {
              throw new Error("tried to replace -1 but scene texture was undefined");
            }
            tex.scene = tex.back;
          }
          tex.back = savedTexture;
          if (settings_1.settings.verbosity > 99) {
            console.log("post final back", tex.back.name);
            console.log("post final front", tex.front.name);
            console.log("channel texture", tex.bufTextures[target].name);
          }
        }
      }
      delete(gl) {
        if (this.programElement instanceof WebGLProgramLeaf) {
          gl.deleteProgram(this.programElement.program);
        } else {
          for (const p of this.programElement) {
            p.delete(gl);
          }
        }
      }
    };
    exports.WebGLProgramLoop = WebGLProgramLoop;
  }
});

// node_modules/@bandaloo/merge-pass/dist/glslfunctions.js
var require_glslfunctions = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/glslfunctions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.glslFuncs = void 0;
    exports.glslFuncs = {
      // TODO bad to calculate single pixel width every time; maybe it can be a need
      texture2D_region: `vec4 texture2D_region(
  float r_x_min,
  float r_y_min,
  float r_x_max,
  float r_y_max,
  sampler2D sampler,
  vec2 uv
) {
  vec2 d = vec2(1., 1.) / uResolution; // pixel width
  return texture2D(sampler, clamp(uv, vec2(r_x_min + d.x, r_y_min + d.x), vec2(r_x_max - d.y, r_y_max - d.y)));
}`,
      // TODO replace with a better one
      // adapted from The Book of Shaders
      random: `float random(vec2 st) {
  return fract(sin(dot(st.xy / 99., vec2(12.9898, 78.233))) * 43758.5453123);
}`,
      // adapted from The Book of Shaders
      random2: `vec2 random2(vec2 st) {
  st = vec2(dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)));
  return -1.0 + 2.0*fract(sin(st)*43758.5453123);
}`,
      rotate2d: `vec2 rotate2d(vec2 v, float angle) {
  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * v;
}`,
      // adapted from The Book of Shaders
      hsv2rgb: `vec4 hsv2rgb(vec4 co){
  vec3 c = co.xyz;
  vec3 rgb = clamp(abs(mod(
    c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
  rgb = rgb * rgb * (3.0 - 2.0 * rgb);
  vec3 hsv = c.z * mix(vec3(1.0), rgb, c.y);
  return vec4(hsv.x, hsv.y, hsv.z, co.a);
}`,
      // adapted from The Book of Shaders
      rgb2hsv: `vec4 rgb2hsv(vec4 co){
  vec3 c = co.rgb;
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec4(abs(q.z + (q.w - q.y) / (6.0 * d + e)),
              d / (q.x + e),
              q.x, co.a);
}`,
      // all gaussian blurs adapted from:
      // https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/5.glsl
      gauss5: `vec4 gauss5(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.3333333333333333) * dir;
  col += texture2D(uSampler, uv) * 0.29411764705882354;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.35294117647058826;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.35294117647058826;
  return col;
}`,
      gauss9: `vec4 gauss9(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.3846153846) * dir;
  vec2 off2 = vec2(3.2307692308) * dir;
  col += texture2D(uSampler, uv) * 0.2270270270;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.3162162162;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.3162162162;
  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.0702702703;
  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.0702702703;
  return col;
}`,
      gauss13: `vec4 gauss13(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.411764705882353) * dir;
  vec2 off2 = vec2(3.2941176470588234) * dir;
  vec2 off3 = vec2(5.176470588235294) * dir;
  col += texture2D(uSampler, uv) * 0.1964825501511404;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.2969069646728344;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.2969069646728344;
  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.09447039785044732;
  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.09447039785044732;
  col += texture2D(uSampler, uv + (off3 / uResolution)) * 0.010381362401148057;
  col += texture2D(uSampler, uv - (off3 / uResolution)) * 0.010381362401148057;
  return col;
}`,
      contrast: `vec4 contrast(float val, vec4 col) {
  col.rgb /= col.a;
  col.rgb = ((col.rgb - 0.5) * val) + 0.5;
  col.rgb *= col.a;
  return col;
}`,
      brightness: `vec4 brightness(float val, vec4 col) {
  col.rgb /= col.a;
  col.rgb += val;
  col.rgb *= col.a;
  return col;
}`,
      // adapted from https://www.shadertoy.com/view/ls3GWS which was adapted from
      // http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/
      // original algorithm created by Timothy Lottes
      fxaa: `vec4 fxaa() {
  float FXAA_SPAN_MAX = 8.0;
  float FXAA_REDUCE_MUL = 1.0 / FXAA_SPAN_MAX;
  float FXAA_REDUCE_MIN = 1.0 / 128.0;
  float FXAA_SUBPIX_SHIFT = 1.0 / 4.0;

  vec2 rcpFrame = 1. / uResolution.xy;
  vec2 t_uv = gl_FragCoord.xy / uResolution.xy; 
  vec4 uv = vec4(t_uv, t_uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));

  vec3 rgbNW = texture2D(uSampler, uv.zw).xyz;
  vec3 rgbNE = texture2D(uSampler, uv.zw + vec2(1,0) * rcpFrame.xy).xyz;
  vec3 rgbSW = texture2D(uSampler, uv.zw + vec2(0,1) * rcpFrame.xy).xyz;
  vec3 rgbSE = texture2D(uSampler, uv.zw + vec2(1,1) * rcpFrame.xy).xyz;
  vec4 rgbMfull = texture2D(uSampler, uv.xy);
  vec3 rgbM = rgbMfull.xyz;
  float alpha = rgbMfull.a;

  vec3 luma = vec3(0.299, 0.587, 0.114);
  float lumaNW = dot(rgbNW, luma);
  float lumaNE = dot(rgbNE, luma);
  float lumaSW = dot(rgbSW, luma);
  float lumaSE = dot(rgbSE, luma);
  float lumaM = dot(rgbM,  luma);

  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

  vec2 dir;
  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));

  float dirReduce = max(
    (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
  float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

  dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
    max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
    dir * rcpDirMin)) * rcpFrame.xy;

  vec3 rgbA = (1.0 / 2.0) * (
    texture2D(uSampler, uv.xy + dir * (1.0 / 3.0 - 0.5)).xyz +
    texture2D(uSampler, uv.xy + dir * (2.0 / 3.0 - 0.5)).xyz);
  vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (
    texture2D(uSampler, uv.xy + dir * (0.0 / 3.0 - 0.5)).xyz +
    texture2D(uSampler, uv.xy + dir * (3.0 / 3.0 - 0.5)).xyz);

  float lumaB = dot(rgbB, luma);

  if (lumaB < lumaMin || lumaB > lumaMax) {
    return vec4(rgbA.r, rgbA.g, rgbA.b, alpha);
  }

  return vec4(rgbB.r, rgbB.g, rgbB.b, alpha);
}`,
      // normal curve is a = 0 and b = 1
      gaussian: `float gaussian(float x, float a, float b) {
  float e = 2.71828;
  return pow(e, -pow(x - a, 2.) / b);
}`,
      // for calculating the true distance from 0 to 1 depth buffer
      // the small delta is to prevent division by zero, which is undefined behavior
      truedepth: `float truedepth(float i) {
  i = max(i, 0.00000001);
  return (1. - i) / i;
}`,
      // based off of https://fabiensanglard.net/lightScattering/index.php
      godrays: `vec4 godrays(
  vec4 col,
  float exposure,
  float decay,
  float density,
  float weight,
  vec2 lightPos,
  float threshold,
  vec4 newColor
) {
  vec2 texCoord = gl_FragCoord.xy / uResolution;
  vec2 deltaTexCoord = texCoord - lightPos;

  const int NUM_SAMPLES = 100;
  deltaTexCoord *= 1. / float(NUM_SAMPLES) * density;
  float illuminationDecay = 1.0;

  for (int i=0; i < NUM_SAMPLES; i++) {
    texCoord -= deltaTexCoord;
    vec4 sample = texture2D(uSampler, texCoord);
    //uncomment sample = depth2occlusion(sample, newColor, threshold);
    sample *= illuminationDecay * weight;
    col += sample;
    illuminationDecay *= decay;
  }
  return col * exposure;
}`,
      depth2occlusion: `vec4 depth2occlusion(vec4 depthCol, vec4 newCol, float threshold) {
  float red = 1. - ceil(depthCol.r - threshold);
  return vec4(newCol.rgb * red, 1.0);
}`,
      // adapted from The Book of Shaders, which was adapted from Inigo Quilez
      // from this example: https://www.shadertoy.com/view/XdXGW8
      gradientnoise: `float gradientnoise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);

  vec2 u = f * f * (3.0 - 2.0 * f);

  return mix(mix(dot(random2(i + vec2(0.0,0.0)), f - vec2(0.0, 0.0)),
                     dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)), u.x),
             mix(dot(random2(i + vec2(0.0,1.0)), f - vec2(0.0, 1.0)),
                 dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)), u.x), u.y);
}`,
      // adapted from The Book of Shaders
      // https://thebookofshaders.com/edit.php#11/2d-snoise-clear.frag
      // this was adapted from this fast implementation
      // https://github.com/ashima/webgl-noise
      // simplex noise invented by Ken Perlin
      simplexnoise: `float simplexnoise(vec2 v) {
  // Precompute values for skewed triangular grid
  const vec4 C = vec4(0.211324865405187,
                      // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,
                      // 0.5*(sqrt(3.0)-1.0)
                      -0.577350269189626,
                      // -1.0 + 2.0 * C.x
                      0.024390243902439);
                      // 1.0 / 41.0

  // First corner (x0)
  vec2 i  = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);

  // Other two corners (x1, x2)
  vec2 i1 = vec2(0.0);
  i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);
  vec2 x1 = x0.xy + C.xx - i1;
  vec2 x2 = x0.xy + C.zz;

  // Do some permutations to avoid
  // truncation effects in permutation
  i = mod289_2(i);
  vec3 p = permute(
          permute( i.y + vec3(0.0, i1.y, 1.0))
              + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(
                      dot(x0,x0),
                      dot(x1,x1),
                      dot(x2,x2)
                      ), 0.0);

  m = m*m ;
  m = m*m ;

  // Gradients:
  //  41 pts uniformly over a line, mapped onto a diamond
  //  The ring size 17*17 = 289 is close to a multiple
  //      of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

  // Normalise gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt(a0*a0 + h*h);
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);

  // Compute final noise value at P
  vec3 g = vec3(0.0);
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);
  return 130.0 * dot(m, g);
}`,
      // only useful for simplex noise
      simplexhelpers: `vec3 mod289_3(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289_3(((x*34.0)+1.0)*x); }`,
      // sobel adapted from https://gist.github.com/Hebali/6ebfc66106459aacee6a9fac029d0115
      sobel: `vec4 sobel() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 k[8];

  float w = 1. / uResolution.x;
  float h = 1. / uResolution.y;

  k[0] = texture2D(uSampler, uv + vec2(-w, -h));
  k[1] = texture2D(uSampler, uv + vec2(0., -h));
  k[2] = texture2D(uSampler, uv + vec2(w, -h));
  k[3] = texture2D(uSampler, uv + vec2(-w, 0.));

  k[4] = texture2D(uSampler, uv + vec2(w, 0.));
  k[5] = texture2D(uSampler, uv + vec2(-w, h));
  k[6] = texture2D(uSampler, uv + vec2(0., h));
  k[7] = texture2D(uSampler, uv + vec2(w, h));

  vec4 edge_h = k[2] + (2. * k[4]) + k[7] - (k[0] + (2. * k[3]) + k[5]);
  vec4 edge_v = k[0] + (2. * k[1]) + k[2] - (k[5] + (2. * k[6]) + k[7]);
  vec4 sob = sqrt(edge_h * edge_h + edge_v * edge_v);

  return vec4(1. - sob.rgb, 1.);
}`,
      // inlining a similar function will substitute in the full expression for
      // every component, so it's more efficient to have a function
      monochrome: `vec4 monochrome(vec4 col) {
  return vec4(vec3((col.r + col.g + col.b) / 3.), col.a);
}`,
      invert: `vec4 invert(vec4 col) {
  return vec4(vec3(1., 1., 1.) - col.rgb, col.a);
}`,
      channel: `vec4 channel(vec2 uv, sampler2D sampler) {
  return texture2D(sampler, uv);
}`
    };
  }
});

// node_modules/@bandaloo/merge-pass/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.brandWithRegion = exports.brandWithChannel = exports.captureAndAppend = void 0;
    var glslfunctions_1 = require_glslfunctions();
    function captureAndAppend(str, reg, suffix) {
      const matches = str.match(reg);
      if (matches === null)
        throw new Error("no match in the given string");
      return str.replace(reg, matches[0] + suffix);
    }
    exports.captureAndAppend = captureAndAppend;
    function nameExtractor(sourceLists, extra) {
      const origFuncName = sourceLists.sections[0];
      const ending = origFuncName[origFuncName.length - 1] === ")" ? ")" : "";
      const newFuncName = origFuncName.substr(0, origFuncName.length - 1 - ~~(ending === ")")) + extra + "(" + ending;
      return { origFuncName, newFuncName, ending };
    }
    function brandWithChannel(sourceLists, funcs, needs, funcIndex, samplerNum) {
      samplerNum === void 0 || samplerNum === -1 ? needs.neighborSample = true : needs.extraBuffers = /* @__PURE__ */ new Set([samplerNum]);
      if (samplerNum === void 0 || samplerNum === -1)
        return;
      const { origFuncName, newFuncName, ending } = nameExtractor(sourceLists, samplerNum !== void 0 ? "_" + samplerNum : "");
      sourceLists.sections[0] = sourceLists.sections[0].split(origFuncName).join(newFuncName);
      funcs[funcIndex] = funcs[funcIndex].split(origFuncName).join(newFuncName).split("uSampler").join("uBufferSampler" + samplerNum);
    }
    exports.brandWithChannel = brandWithChannel;
    function brandWithRegion(expr, funcIndex, space) {
      if (!Array.isArray(space))
        return;
      const sourceLists = expr.sourceLists;
      const funcs = expr.externalFuncs;
      const needs = expr.needs;
      if (expr.regionBranded || !needs.neighborSample && needs.extraBuffers.size === 0)
        return;
      const { origFuncName, newFuncName, ending } = nameExtractor(sourceLists, "_region");
      const openFuncName = newFuncName.substr(0, newFuncName.length - ~~(ending === ")"));
      const newFuncDeclaration = openFuncName + "float r_x_min, float r_y_min, float r_x_max, float r_y_max" + (ending === ")" ? ")" : ", ");
      const origTextureName = "texture2D(";
      const newTextureName = "texture2D_region(r_x_min, r_y_min, r_x_max, r_y_max, ";
      funcs[funcIndex] = funcs[funcIndex].split(origFuncName).join(newFuncDeclaration).split(origTextureName).join(newTextureName);
      sourceLists.sections.shift();
      if (ending === ")")
        sourceLists.sections.unshift(")");
      for (let i = 0; i < 4 - ~~(ending === ")"); i++) {
        sourceLists.sections.unshift(", ");
      }
      sourceLists.sections.unshift(newFuncName.substr(0, newFuncName.length - ~~(ending === ")")));
      sourceLists.values.unshift(...space);
      funcs.unshift(glslfunctions_1.glslFuncs.texture2D_region);
      expr.regionBranded = true;
    }
    exports.brandWithRegion = brandWithRegion;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/expr.js
var require_expr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/expr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tag = exports.wrapInValue = exports.pfloat = exports.Operator = exports.WrappedExpr = exports.ExprVec4 = exports.ExprVec3 = exports.ExprVec2 = exports.float = exports.ExprFloat = exports.BasicFloat = exports.ExprVec = exports.BasicVec4 = exports.BasicVec3 = exports.BasicVec2 = exports.BasicVec = exports.PrimitiveVec4 = exports.PrimitiveVec3 = exports.PrimitiveVec2 = exports.PrimitiveVec = exports.PrimitiveFloat = exports.Primitive = exports.mut = exports.Mutable = exports.cvec4 = exports.cvec3 = exports.cvec2 = exports.cfloat = exports.Expr = void 0;
    var mergepass_1 = require_mergepass();
    var webglprogramloop_1 = require_webglprogramloop();
    var utils_1 = require_utils();
    function toGLSLFloatString(num) {
      let str = "" + num;
      if (!str.includes("."))
        str += ".";
      return str;
    }
    var Expr = class {
      constructor(sourceLists, defaultNames) {
        this.needs = {
          neighborSample: false,
          centerSample: false,
          sceneBuffer: false,
          timeUniform: false,
          mouseUniform: false,
          passCount: false,
          extraBuffers: /* @__PURE__ */ new Set()
        };
        this.uniformValChangeMap = {};
        this.defaultNameMap = {};
        this.externalFuncs = [];
        this.sourceCode = "";
        this.funcIndex = 0;
        this.regionBranded = false;
        this.id = "_id_" + Expr.count;
        Expr.count++;
        if (sourceLists.sections.length - sourceLists.values.length !== 1) {
          throw new Error("wrong lengths for source and values");
        }
        if (sourceLists.values.length !== defaultNames.length) {
          console.log(sourceLists);
          console.log(defaultNames);
          throw new Error("default names list length doesn't match values list length");
        }
        this.sourceLists = sourceLists;
        this.defaultNames = defaultNames;
      }
      applyUniforms(gl, uniformLocs) {
        for (const name in this.uniformValChangeMap) {
          const loc = uniformLocs[name];
          if (this.uniformValChangeMap[name].changed) {
            this.uniformValChangeMap[name].val.applyUniform(gl, loc.locs[loc.counter]);
          }
          loc.counter++;
          loc.counter %= loc.locs.length;
          if (loc.counter === 0) {
            this.uniformValChangeMap[name].changed = false;
          }
        }
      }
      getSampleNum(mult = 1) {
        return this.needs.neighborSample ? mult : this.sourceLists.values.map((v) => v.getSampleNum()).reduce((acc, curr) => acc + curr, 0) > 0 ? mult : 0;
      }
      /**
       * set a uniform by name directly
       * @param name uniform name in the source code
       * @param newVal value to set the uniform to
       */
      setUniform(name, newVal) {
        var _a, _b;
        newVal = wrapInValue(newVal);
        const originalName = name;
        if (typeof newVal === "number") {
          newVal = wrapInValue(newVal);
        }
        if (!(newVal instanceof Primitive)) {
          throw new Error("cannot set a non-primitive");
        }
        if (((_a = this.uniformValChangeMap[name]) === null || _a === void 0 ? void 0 : _a.val) === void 0) {
          name = this.defaultNameMap[name];
        }
        const oldVal = (_b = this.uniformValChangeMap[name]) === null || _b === void 0 ? void 0 : _b.val;
        if (oldVal === void 0) {
          throw new Error("tried to set uniform " + name + " which doesn't exist. original name: " + originalName);
        }
        if (oldVal.typeString() !== newVal.typeString()) {
          throw new Error("tried to set uniform " + name + " to a new type");
        }
        this.uniformValChangeMap[name].val = newVal;
        this.uniformValChangeMap[name].changed = true;
      }
      /**
       * parses this expression into a string, adding info as it recurses into
       * nested expressions
       */
      parse(buildInfo) {
        this.sourceCode = "";
        buildInfo.exprs.push(this);
        buildInfo.needs = webglprogramloop_1.updateNeeds(buildInfo.needs, this.needs);
        this.externalFuncs.forEach((func) => buildInfo.externalFuncs.add(func));
        for (let i = 0; i < this.sourceLists.values.length; i++) {
          this.sourceCode += this.sourceLists.sections[i] + this.sourceLists.values[i].parse(buildInfo, this.defaultNames[i], this);
        }
        this.sourceCode += this.sourceLists.sections[this.sourceLists.sections.length - 1];
        return this.sourceCode;
      }
      addFuncs(funcs) {
        this.externalFuncs.push(...funcs);
        return this;
      }
      brandExprWithChannel(funcIndex, samplerNum) {
        utils_1.brandWithChannel(this.sourceLists, this.externalFuncs, this.needs, funcIndex, samplerNum);
        return this;
      }
      brandExprWithRegion(space) {
        utils_1.brandWithRegion(this, this.funcIndex, space);
        for (const v of this.sourceLists.values) {
          v.brandExprWithRegion(space);
        }
        return this;
      }
    };
    exports.Expr = Expr;
    Expr.count = 0;
    function genCustomNames(sourceLists) {
      const names = [];
      for (let i = 0; i < sourceLists.values.length; i++) {
        names.push("uCustomName" + i);
      }
      return names;
    }
    function cfloat(sourceLists, externalFuncs = []) {
      return new ExprFloat(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
    }
    exports.cfloat = cfloat;
    function cvec2(sourceLists, externalFuncs = []) {
      return new ExprVec2(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
    }
    exports.cvec2 = cvec2;
    function cvec3(sourceLists, externalFuncs = []) {
      return new ExprVec3(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
    }
    exports.cvec3 = cvec3;
    function cvec4(sourceLists, externalFuncs = []) {
      return new ExprVec4(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
    }
    exports.cvec4 = cvec4;
    var Mutable = class {
      constructor(primitive, name) {
        this.primitive = primitive;
        this.name = name;
      }
      parse(buildInfo, defaultName, enc) {
        if (enc === void 0) {
          throw new Error("tried to put a mutable expression at the top level");
        }
        if (this.name === void 0)
          this.name = defaultName + enc.id;
        buildInfo.uniformTypes[this.name] = this.primitive.typeString();
        enc.uniformValChangeMap[this.name] = {
          val: this.primitive,
          changed: true
        };
        enc.defaultNameMap[defaultName + enc.id] = this.name;
        return this.name;
      }
      applyUniform(gl, loc) {
        this.primitive.applyUniform(gl, loc);
      }
      typeString() {
        return this.primitive.typeString();
      }
      getSampleNum() {
        return 0;
      }
      brandExprWithRegion(space) {
        return this;
      }
    };
    exports.Mutable = Mutable;
    function mut(val, name) {
      const primitive = typeof val === "number" ? wrapInValue(val) : val;
      return new Mutable(primitive, name);
    }
    exports.mut = mut;
    var Primitive = class {
      parse() {
        return this.toString();
      }
      getSampleNum() {
        return 0;
      }
      brandExprWithRegion(space) {
        return this;
      }
    };
    exports.Primitive = Primitive;
    var PrimitiveFloat = class extends Primitive {
      constructor(num) {
        if (!isFinite(num))
          throw new Error("number not finite");
        super();
        this.value = num;
      }
      toString() {
        let str = "" + this.value;
        if (!str.includes("."))
          str += ".";
        return str;
      }
      typeString() {
        return "float";
      }
      applyUniform(gl, loc) {
        gl.uniform1f(loc, this.value);
      }
    };
    exports.PrimitiveFloat = PrimitiveFloat;
    var PrimitiveVec = class extends Primitive {
      constructor(comps) {
        super();
        this.values = comps;
      }
      typeString() {
        return "vec" + this.values.length;
      }
      toString() {
        return `${this.typeString()}(${this.values.map((n) => toGLSLFloatString(n)).join(", ")})`;
      }
    };
    exports.PrimitiveVec = PrimitiveVec;
    var PrimitiveVec2 = class extends PrimitiveVec {
      applyUniform(gl, loc) {
        gl.uniform2f(loc, this.values[0], this.values[1]);
      }
    };
    exports.PrimitiveVec2 = PrimitiveVec2;
    var PrimitiveVec3 = class extends PrimitiveVec {
      applyUniform(gl, loc) {
        gl.uniform3f(loc, this.values[0], this.values[1], this.values[2]);
      }
    };
    exports.PrimitiveVec3 = PrimitiveVec3;
    var PrimitiveVec4 = class extends PrimitiveVec {
      applyUniform(gl, loc) {
        gl.uniform4f(loc, this.values[0], this.values[1], this.values[2], this.values[3]);
      }
    };
    exports.PrimitiveVec4 = PrimitiveVec4;
    var BasicVec = class extends Expr {
      constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        const values = sourceLists.values;
        this.values = values;
        this.defaultNames = defaultNames;
      }
      typeString() {
        return "vec" + this.values.length;
      }
      /** sets a component of the vector */
      setComp(index, primitive) {
        if (index < 0 || index >= this.values.length) {
          throw new Error("out of bounds of setting component");
        }
        this.setUniform(this.defaultNames[index] + this.id, wrapInValue(primitive));
      }
    };
    exports.BasicVec = BasicVec;
    var BasicVec2 = class extends BasicVec {
      constructor() {
        super(...arguments);
        this.bvec2 = void 0;
      }
    };
    exports.BasicVec2 = BasicVec2;
    var BasicVec3 = class extends BasicVec {
      constructor() {
        super(...arguments);
        this.bvec3 = void 0;
      }
    };
    exports.BasicVec3 = BasicVec3;
    var BasicVec4 = class extends BasicVec {
      constructor() {
        super(...arguments);
        this.bvec4 = void 0;
      }
    };
    exports.BasicVec4 = BasicVec4;
    var ExprVec = class extends Expr {
      constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        const values = sourceLists.values;
        this.values = values;
        this.defaultNames = defaultNames;
      }
    };
    exports.ExprVec = ExprVec;
    var BasicFloat = class extends Expr {
      constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.float = void 0;
      }
      setVal(primitive) {
        this.setUniform("uFloat" + this.id, wrapInValue(primitive));
      }
      typeString() {
        return "float";
      }
    };
    exports.BasicFloat = BasicFloat;
    var ExprFloat = class extends Expr {
      constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.float = void 0;
      }
      setVal(primitive) {
        this.setUniform("uFloat" + this.id, wrapInValue(primitive));
      }
      typeString() {
        return "float";
      }
    };
    exports.ExprFloat = ExprFloat;
    function float(value) {
      if (typeof value === "number")
        value = wrapInValue(value);
      return new BasicFloat({ sections: ["", ""], values: [value] }, ["uFloat"]);
    }
    exports.float = float;
    var ExprVec2 = class extends ExprVec {
      constructor() {
        super(...arguments);
        this.vec2 = void 0;
      }
      typeString() {
        return "vec2";
      }
    };
    exports.ExprVec2 = ExprVec2;
    var ExprVec3 = class extends ExprVec {
      constructor() {
        super(...arguments);
        this.vec3 = void 0;
      }
      typeString() {
        return "vec3";
      }
    };
    exports.ExprVec3 = ExprVec3;
    var ExprVec4 = class extends ExprVec {
      constructor() {
        super(...arguments);
        this.vec4 = void 0;
      }
      repeat(num) {
        return new mergepass_1.EffectLoop([this], { num });
      }
      genPrograms(gl, vShader, uniformLocs, shaders) {
        return new mergepass_1.EffectLoop([this], { num: 1 }).genPrograms(gl, vShader, uniformLocs, shaders);
      }
      typeString() {
        return "vec4";
      }
    };
    exports.ExprVec4 = ExprVec4;
    var WrappedExpr = class {
      constructor(expr) {
        this.expr = expr;
      }
      typeString() {
        return this.expr.typeString();
      }
      parse(buildInfo, defaultName, enc) {
        return this.expr.parse(buildInfo, defaultName, enc);
      }
      getSampleNum() {
        return this.expr.getSampleNum();
      }
      brandExprWithRegion(space) {
        return this.expr.brandExprWithRegion(space);
      }
    };
    exports.WrappedExpr = WrappedExpr;
    var Operator = class extends Expr {
      constructor(ret, sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.ret = ret;
      }
      typeString() {
        return this.ret.typeString();
      }
    };
    exports.Operator = Operator;
    function pfloat(num) {
      return new PrimitiveFloat(num);
    }
    exports.pfloat = pfloat;
    function wrapInValue(num) {
      if (num === void 0)
        return void 0;
      if (typeof num === "number")
        return pfloat(num);
      return num;
    }
    exports.wrapInValue = wrapInValue;
    function tag(strings, ...values) {
      return { sections: strings.concat([]), values };
    }
    exports.tag = tag;
  }
});

// node_modules/@bandaloo/merge-pass/dist/codebuilder.js
var require_codebuilder = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/codebuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeBuilder = exports.channelSamplerName = void 0;
    var expr_1 = require_expr();
    var webglprogramloop_1 = require_webglprogramloop();
    var settings_1 = require_settings();
    var FRAG_SET = `  gl_FragColor = texture2D(uSampler, gl_FragCoord.xy / uResolution);
`;
    var SCENE_SET = `uniform sampler2D uSceneSampler;
`;
    var TIME_SET = `uniform mediump float uTime;
`;
    var MOUSE_SET = `uniform mediump vec2 uMouse;
`;
    var COUNT_SET = `uniform int uCount;
`;
    var BOILERPLATE = `#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D uSampler;
uniform mediump vec2 uResolution;
`;
    function channelSamplerName(num) {
      return num === -1 ? "uSampler" : `uBufferSampler${num}`;
    }
    exports.channelSamplerName = channelSamplerName;
    function channelSamplerDeclaration(num) {
      return `uniform sampler2D ${channelSamplerName(num)};`;
    }
    var CodeBuilder = class {
      constructor(effectLoop) {
        this.calls = [];
        this.externalFuncs = /* @__PURE__ */ new Set();
        this.uniformDeclarations = /* @__PURE__ */ new Set();
        this.counter = 0;
        this.baseLoop = effectLoop;
        const buildInfo = {
          uniformTypes: {},
          externalFuncs: /* @__PURE__ */ new Set(),
          exprs: [],
          // update me on change to needs
          needs: {
            centerSample: false,
            neighborSample: false,
            sceneBuffer: false,
            timeUniform: false,
            mouseUniform: false,
            passCount: false,
            extraBuffers: /* @__PURE__ */ new Set()
          }
        };
        this.addEffectLoop(effectLoop, 1, buildInfo);
        for (const name in buildInfo.uniformTypes) {
          const typeName = buildInfo.uniformTypes[name];
          this.uniformDeclarations.add(`uniform mediump ${typeName} ${name};`);
        }
        buildInfo.externalFuncs.forEach((func) => this.externalFuncs.add(func));
        this.totalNeeds = buildInfo.needs;
        this.exprs = buildInfo.exprs;
      }
      addEffectLoop(effectLoop, indentLevel, buildInfo, topLevel = true) {
        const needsLoop = !topLevel && effectLoop.loopInfo.num > 1;
        if (needsLoop) {
          const iName = "i" + this.counter;
          indentLevel++;
          const forStart = "  ".repeat(indentLevel - 1) + `for (int ${iName} = 0; ${iName} < ${effectLoop.loopInfo.num}; ${iName}++) {`;
          this.calls.push(forStart);
        }
        for (const e of effectLoop.effects) {
          if (e instanceof expr_1.Expr) {
            e.parse(buildInfo);
            this.calls.push("  ".repeat(indentLevel) + "gl_FragColor = " + e.sourceCode + ";");
            this.counter++;
          } else {
            this.addEffectLoop(e, indentLevel, buildInfo, false);
          }
        }
        if (needsLoop) {
          this.calls.push("  ".repeat(indentLevel - 1) + "}");
        }
      }
      /** generate the code and compile the program into a loop */
      compileProgram(gl, vShader, uniformLocs, shaders = []) {
        const fShader = gl.createShader(gl.FRAGMENT_SHADER);
        if (fShader === null) {
          throw new Error("problem creating fragment shader");
        }
        const fullCode = BOILERPLATE + (this.totalNeeds.sceneBuffer ? SCENE_SET : "") + (this.totalNeeds.timeUniform ? TIME_SET : "") + (this.totalNeeds.mouseUniform ? MOUSE_SET : "") + (this.totalNeeds.passCount ? COUNT_SET : "") + Array.from(this.totalNeeds.extraBuffers).map((n) => channelSamplerDeclaration(n)).join("\n") + "\n" + [...this.uniformDeclarations].join("\n") + "\n" + [...this.externalFuncs].join("\n") + "\nvoid main() {\n" + (this.totalNeeds.centerSample ? FRAG_SET : "") + this.calls.join("\n") + "\n}";
        if (settings_1.settings.verbosity > 0)
          console.log(fullCode);
        gl.shaderSource(fShader, fullCode);
        gl.compileShader(fShader);
        const program = gl.createProgram();
        if (program === null) {
          throw new Error("problem creating program");
        }
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        shaders.push(fShader);
        const shaderLog = (name, shader) => {
          const output = gl.getShaderInfoLog(shader);
          if (output)
            console.log(`${name} shader info log
${output}`);
        };
        shaderLog("vertex", vShader);
        shaderLog("fragment", fShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        for (const expr of this.exprs) {
          for (const name in expr.uniformValChangeMap) {
            const location = gl.getUniformLocation(program, name);
            if (location === null) {
              throw new Error("couldn't find uniform " + name);
            }
            if (uniformLocs[name] === void 0) {
              uniformLocs[name] = { locs: [], counter: 0 };
            }
            uniformLocs[name].locs.push(location);
          }
        }
        const uResolution = gl.getUniformLocation(program, "uResolution");
        gl.uniform2f(uResolution, gl.drawingBufferWidth, gl.drawingBufferHeight);
        if (this.totalNeeds.sceneBuffer) {
          const location = gl.getUniformLocation(program, "uSceneSampler");
          gl.uniform1i(location, 1 + settings_1.settings.offset);
        }
        for (const b of this.totalNeeds.extraBuffers) {
          const location = gl.getUniformLocation(program, channelSamplerName(b));
          gl.uniform1i(location, b + 2 + settings_1.settings.offset);
        }
        if (settings_1.settings.offset !== 0) {
          const location = gl.getUniformLocation(program, "uSampler");
          gl.uniform1i(location, settings_1.settings.offset);
        }
        const position = gl.getAttribLocation(program, "aPosition");
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
        return new webglprogramloop_1.WebGLProgramLoop(new webglprogramloop_1.WebGLProgramLeaf(program, this.totalNeeds, this.exprs), this.baseLoop.loopInfo, gl);
      }
    };
    exports.CodeBuilder = CodeBuilder;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/fragcolorexpr.js
var require_fragcolorexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/fragcolorexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fcolor = exports.FragColorExpr = void 0;
    var expr_1 = require_expr();
    var FragColorExpr = class extends expr_1.ExprVec4 {
      constructor() {
        super(expr_1.tag`gl_FragColor`, []);
        this.needs.centerSample = true;
      }
    };
    exports.FragColorExpr = FragColorExpr;
    function fcolor() {
      return new FragColorExpr();
    }
    exports.fcolor = fcolor;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/getcompexpr.js
var require_getcompexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/getcompexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.get4comp = exports.get3comp = exports.get2comp = exports.getcomp = exports.Get4CompExpr = exports.Get3CompExpr = exports.Get2CompExpr = exports.GetCompExpr = exports.checkLegalComponents = exports.typeStringToLength = void 0;
    var expr_1 = require_expr();
    function typeStringToLength(str) {
      switch (str) {
        case "float":
          return 1;
        case "vec2":
          return 2;
        case "vec3":
          return 3;
        case "vec4":
          return 4;
      }
    }
    exports.typeStringToLength = typeStringToLength;
    function genCompSource(vec, components) {
      return {
        sections: ["", "." + components],
        values: [vec]
      };
    }
    function checkLegalComponents(comps, vec) {
      const check = (range, domain) => {
        let inside = 0;
        let outside = 0;
        for (const c of range) {
          domain.includes(c) ? inside++ : outside++;
        }
        return inside === inside && !outside;
      };
      const inLen = typeStringToLength(vec.typeString());
      const rgbaCheck = check(comps, "rgba".substr(0, inLen));
      const xyzwCheck = check(comps, "xyzw".substr(0, inLen));
      const stpqCheck = check(comps, "stpq".substr(0, inLen));
      if (!(rgbaCheck || xyzwCheck || stpqCheck)) {
        throw new Error("component sets are mixed or incorrect entirely");
      }
    }
    exports.checkLegalComponents = checkLegalComponents;
    function checkGetComponents(comps, outLen, vec) {
      if (comps.length > outLen)
        throw new Error("too many components");
      checkLegalComponents(comps, vec);
    }
    var GetCompExpr = class extends expr_1.ExprFloat {
      constructor(vec, comps) {
        checkGetComponents(comps, 1, vec);
        super(genCompSource(vec, comps), ["uVec1Min"]);
        this.vec1Min = vec;
      }
      setVec(vec) {
        this.setUniform("uVec1Min", vec);
        this.vec1Min = vec;
      }
    };
    exports.GetCompExpr = GetCompExpr;
    var Get2CompExpr = class extends expr_1.ExprVec2 {
      constructor(vec, comps) {
        checkGetComponents(comps, 2, vec);
        super(genCompSource(vec, comps), ["uVec2Min"]);
        this.vec2Min = vec;
      }
      setVec(vec) {
        this.setUniform("uVec2Min", vec);
        this.vec2Min = vec;
      }
    };
    exports.Get2CompExpr = Get2CompExpr;
    var Get3CompExpr = class extends expr_1.ExprVec3 {
      constructor(vec, comps) {
        checkGetComponents(comps, 3, vec);
        super(genCompSource(vec, comps), ["uVec3Min"]);
        this.vec3Min = vec;
      }
      setVec(vec) {
        this.setUniform("uVec3Min", vec);
        this.vec3Min = vec;
      }
    };
    exports.Get3CompExpr = Get3CompExpr;
    var Get4CompExpr = class extends expr_1.ExprVec4 {
      constructor(vec, comps) {
        checkGetComponents(comps, 4, vec);
        super(genCompSource(vec, comps), ["uVec4Min"]);
        this.vec4Min = vec;
      }
      setVec(vec) {
        this.setUniform("uVec4Min", vec);
        this.vec4Min = vec;
      }
    };
    exports.Get4CompExpr = Get4CompExpr;
    function getcomp(vec, comps) {
      return new GetCompExpr(vec, comps);
    }
    exports.getcomp = getcomp;
    function get2comp(vec, comps) {
      return new Get2CompExpr(vec, comps);
    }
    exports.get2comp = get2comp;
    function get3comp(vec, comps) {
      return new Get3CompExpr(vec, comps);
    }
    exports.get3comp = get3comp;
    function get4comp(vec, comps) {
      return new Get4CompExpr(vec, comps);
    }
    exports.get4comp = get4comp;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/normfragcoordexpr.js
var require_normfragcoordexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/normfragcoordexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pos = exports.NormFragCoordExpr = void 0;
    var expr_1 = require_expr();
    var NormFragCoordExpr = class extends expr_1.ExprVec2 {
      constructor() {
        super(expr_1.tag`(gl_FragCoord.xy / uResolution)`, []);
      }
    };
    exports.NormFragCoordExpr = NormFragCoordExpr;
    function pos() {
      return new NormFragCoordExpr();
    }
    exports.pos = pos;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/opexpr.js
var require_opexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/opexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.op = exports.OpExpr = void 0;
    var expr_1 = require_expr();
    function genOpSourceList(left, op2, right) {
      return {
        sections: ["(", ` ${op2} `, ")"],
        values: [left, right]
      };
    }
    var OpExpr = class extends expr_1.Operator {
      constructor(left, op2, right) {
        super(left, genOpSourceList(left, op2, right), ["uLeft", "uRight"]);
        this.left = left;
        this.right = right;
      }
      setLeft(left) {
        this.setUniform("uLeft" + this.id, left);
        this.left = expr_1.wrapInValue(left);
      }
      setRight(right) {
        this.setUniform("uRight" + this.id, right);
        this.right = expr_1.wrapInValue(right);
      }
    };
    exports.OpExpr = OpExpr;
    function op(left, op2, right) {
      return new OpExpr(expr_1.wrapInValue(left), op2, expr_1.wrapInValue(right));
    }
    exports.op = op;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/ternaryexpr.js
var require_ternaryexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/ternaryexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ternary = exports.TernaryExpr = void 0;
    var expr_1 = require_expr();
    function genTernarySourceList(floats, success, failure, not) {
      const sourceList = {
        sections: [`(${not ? "!" : ""}(`],
        values: []
      };
      let counter = 0;
      if (floats !== null) {
        for (const f of floats) {
          counter++;
          const last = counter === floats.length;
          sourceList.values.push(f);
          sourceList.sections.push(` > 0.${last ? ") ? " : " && "}`);
        }
      } else {
        sourceList.sections[0] += "uCount == 0) ? ";
      }
      sourceList.values.push(success);
      sourceList.sections.push(" : ");
      sourceList.values.push(failure);
      sourceList.sections.push(")");
      return sourceList;
    }
    var TernaryExpr = class extends expr_1.Operator {
      constructor(floats, success, failure, not) {
        super(success, genTernarySourceList(floats, success, failure, not), [
          ...floats !== null ? Array.from(floats, (val, index) => "uFloat" + index) : [],
          "uSuccess",
          "uFailure"
        ]);
        this.success = success;
        this.failure = failure;
        this.needs.passCount = floats === null;
      }
    };
    exports.TernaryExpr = TernaryExpr;
    function ternary(floats, success, failure, not = false) {
      if (!Array.isArray(floats) && floats !== null)
        floats = [floats].map((f) => expr_1.wrapInValue(f));
      return new TernaryExpr(floats, expr_1.wrapInValue(success), expr_1.wrapInValue(failure), not);
    }
    exports.ternary = ternary;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/regiondecorator.js
var require_regiondecorator = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/regiondecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.region = void 0;
    var mergepass_1 = require_mergepass();
    var expr_1 = require_expr();
    var getcompexpr_1 = require_getcompexpr();
    var normfragcoordexpr_1 = require_normfragcoordexpr();
    var opexpr_1 = require_opexpr();
    var ternaryexpr_1 = require_ternaryexpr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    function createDifferenceFloats(floats) {
      const axes = "xy";
      const differences = [];
      if (floats.length !== 4) {
        throw new Error("incorrect amount of points specified for region");
      }
      for (let i = 0; i < 2; i++) {
        differences.push(opexpr_1.op(getcompexpr_1.getcomp(normfragcoordexpr_1.pos(), axes[i]), "-", floats[i]));
      }
      for (let i = 2; i < floats.length; i++) {
        differences.push(opexpr_1.op(floats[i], "-", getcompexpr_1.getcomp(normfragcoordexpr_1.pos(), axes[i - 2])));
      }
      return differences;
    }
    function region(space, success, failure, not = false) {
      const floats = Array.isArray(space) ? space.map((f) => expr_1.wrapInValue(f)) : typeof space === "number" ? expr_1.wrapInValue(space) : space;
      if (failure instanceof mergepass_1.EffectLoop) {
        if (!(success instanceof mergepass_1.EffectLoop)) {
          [success, failure] = [failure, success];
          not = !not;
        }
      }
      if (success instanceof mergepass_1.EffectLoop) {
        if (!(failure instanceof mergepass_1.EffectLoop)) {
          return success.regionWrap(floats, failure, true, not);
        }
        return mergepass_1.loop([
          success.regionWrap(floats, fragcolorexpr_1.fcolor(), false, not),
          failure.regionWrap(floats, fragcolorexpr_1.fcolor(), true, !not)
        ]);
      }
      return ternaryexpr_1.ternary(Array.isArray(floats) ? createDifferenceFloats(floats) : floats, success.brandExprWithRegion(floats), failure.brandExprWithRegion(floats), not);
    }
    exports.region = region;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/scenesampleexpr.js
var require_scenesampleexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/scenesampleexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.input = exports.SceneSampleExpr = void 0;
    var expr_1 = require_expr();
    var normfragcoordexpr_1 = require_normfragcoordexpr();
    var SceneSampleExpr = class extends expr_1.ExprVec4 {
      constructor(coord = normfragcoordexpr_1.pos()) {
        super(expr_1.tag`texture2D(uSceneSampler, ${coord})`, ["uCoord"]);
        this.coord = coord;
        this.needs.sceneBuffer = true;
      }
      /** sets coordinate where scene is being sampled from */
      setCoord(coord) {
        this.setUniform("uCoord", coord);
        this.coord = coord;
      }
    };
    exports.SceneSampleExpr = SceneSampleExpr;
    function input(vec) {
      return new SceneSampleExpr(vec);
    }
    exports.input = input;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/setcolorexpr.js
var require_setcolorexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/setcolorexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetColorExpr = void 0;
    var expr_1 = require_expr();
    var SetColorExpr = class extends expr_1.ExprVec4 {
      constructor(vec) {
        super(expr_1.tag`(${vec})`, ["uVal"]);
        this.vec = vec;
      }
    };
    exports.SetColorExpr = SetColorExpr;
  }
});

// node_modules/@bandaloo/merge-pass/dist/mergepass.js
var require_mergepass = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/mergepass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendTexture = exports.makeTexture = exports.Merger = exports.loop = exports.EffectLoop = exports.EffectDictionary = void 0;
    var codebuilder_1 = require_codebuilder();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var regiondecorator_1 = require_regiondecorator();
    var scenesampleexpr_1 = require_scenesampleexpr();
    var setcolorexpr_1 = require_setcolorexpr();
    var ternaryexpr_1 = require_ternaryexpr();
    var settings_1 = require_settings();
    var webglprogramloop_1 = require_webglprogramloop();
    function wrapInSetColors(effects) {
      return effects.map((e) => e instanceof expr_1.ExprVec4 || e instanceof EffectLoop ? e : new setcolorexpr_1.SetColorExpr(e));
    }
    function processEffectMap(eMap) {
      const result = {};
      for (const name in eMap) {
        const val = eMap[name];
        result[name] = wrapInSetColors(val);
      }
      return result;
    }
    var EffectDictionary = class {
      constructor(effectMap) {
        this.effectMap = processEffectMap(effectMap);
      }
      toProgramMap(gl, vShader, uniformLocs, fShaders) {
        const programMap = {};
        let needs = {
          neighborSample: false,
          centerSample: false,
          sceneBuffer: false,
          timeUniform: false,
          mouseUniform: false,
          passCount: false,
          extraBuffers: /* @__PURE__ */ new Set()
        };
        for (const name in this.effectMap) {
          const effects = this.effectMap[name];
          const effectLoop = new EffectLoop(effects, { num: 1 });
          if (effectLoop.effects.length === 0) {
            throw new Error("list of effects was empty");
          }
          const programLoop = effectLoop.genPrograms(gl, vShader, uniformLocs, fShaders);
          let atBottom = false;
          let currProgramLoop = programLoop;
          while (!atBottom) {
            if (currProgramLoop.programElement instanceof webglprogramloop_1.WebGLProgramLeaf) {
              currProgramLoop.last = true;
              atBottom = true;
            } else {
              currProgramLoop = currProgramLoop.programElement[currProgramLoop.programElement.length - 1];
            }
          }
          needs = webglprogramloop_1.updateNeeds(needs, programLoop.getTotalNeeds());
          programMap[name] = programLoop;
        }
        return { programMap, needs };
      }
    };
    exports.EffectDictionary = EffectDictionary;
    var EffectLoop = class {
      constructor(effects, loopInfo) {
        this.effects = wrapInSetColors(effects);
        this.loopInfo = loopInfo;
      }
      /** @ignore */
      getSampleNum(mult = 1, sliceStart = 0, sliceEnd = this.effects.length) {
        mult *= this.loopInfo.num;
        let acc = 0;
        const sliced = this.effects.slice(sliceStart, sliceEnd);
        for (const e of sliced) {
          acc += e.getSampleNum(mult);
        }
        return acc;
      }
      /**
       * @ignore
       * places effects into loops broken up by sampling effects
       */
      regroup() {
        let sampleCount = 0;
        let prevSampleCount = 0;
        let prevEffects = [];
        const regroupedEffects = [];
        let prevTarget;
        let currTarget;
        let mustBreakCounter = 0;
        const breakOff = () => {
          mustBreakCounter--;
          if (prevEffects.length > 0) {
            if (prevEffects.length === 1) {
              regroupedEffects.push(prevEffects[0]);
            } else {
              regroupedEffects.push(new EffectLoop(prevEffects, { num: 1 }));
            }
            sampleCount -= prevSampleCount;
            prevEffects = [];
          }
        };
        for (const e of this.effects) {
          const sampleNum = e.getSampleNum();
          prevSampleCount = sampleCount;
          sampleCount += sampleNum;
          if (e instanceof EffectLoop) {
            currTarget = e.loopInfo.target;
            if (e.hasTargetSwitch()) {
              mustBreakCounter = 2;
            }
          } else {
            currTarget = this.loopInfo.target;
          }
          if (sampleCount > 0 || currTarget !== prevTarget || mustBreakCounter > 0) {
            breakOff();
          }
          prevEffects.push(e);
          prevTarget = currTarget;
        }
        breakOff();
        return regroupedEffects;
      }
      genPrograms(gl, vShader, uniformLocs, shaders) {
        const fullSampleNum = this.getSampleNum() / this.loopInfo.num;
        const firstSampleNum = this.getSampleNum(void 0, 0, 1) / this.loopInfo.num;
        const restSampleNum = this.getSampleNum(void 0, 1) / this.loopInfo.num;
        if (!this.hasTargetSwitch() && (fullSampleNum === 0 || firstSampleNum === 1 && restSampleNum === 0)) {
          const codeBuilder = new codebuilder_1.CodeBuilder(this);
          const program = codeBuilder.compileProgram(gl, vShader, uniformLocs, shaders);
          return program;
        }
        this.effects = this.regroup();
        return new webglprogramloop_1.WebGLProgramLoop(this.effects.map((e) => e.genPrograms(gl, vShader, uniformLocs, shaders)), this.loopInfo, gl);
      }
      /**
       * changes the render target of an effect loop (-1 targest the scene texture;
       * this is used internally)
       */
      target(num) {
        this.loopInfo.target = num;
        return this;
      }
      /** @ignore */
      hasTargetSwitch() {
        for (const e of this.effects) {
          if (e instanceof EffectLoop) {
            if (e.loopInfo.target !== this.loopInfo.target || e.hasTargetSwitch())
              return true;
          }
        }
        return false;
      }
      /** @ignore */
      regionWrap(space, failure, finalPath = true, not) {
        this.effects = this.effects.map((e, index) => (
          // loops that aren't all the way to the right can't terminate the count ternery
          // don't wrap fcolors in a ternery (it's redundant)
          e instanceof EffectLoop ? e.regionWrap(space, failure, index === this.effects.length - 1, not) : new setcolorexpr_1.SetColorExpr(regiondecorator_1.region(space, e.brandExprWithRegion(space), index === this.effects.length - 1 && finalPath ? !(failure instanceof fragcolorexpr_1.FragColorExpr) ? ternaryexpr_1.ternary(null, failure, fragcolorexpr_1.fcolor()) : failure : fragcolorexpr_1.fcolor(), not))
        ));
        return this;
      }
    };
    exports.EffectLoop = EffectLoop;
    function loop(effects, rep = 1) {
      return new EffectLoop(effects, { num: rep });
    }
    exports.loop = loop;
    var V_SOURCE = `attribute vec2 aPosition;
void main() {
  gl_Position = vec4(aPosition, 0.0, 1.0);
}
`;
    var Merger = class {
      /**
       * constructs the object that runs the effects
       * @param effects list of effects that define the final effect
       * @param source the source image or texture
       * @param gl the target rendering context
       * @param options additional options for the texture
       */
      constructor(effects, source, gl, options) {
        this.uniformLocs = {};
        this.channels = [];
        this.fShaders = [];
        this.textureMode = source instanceof WebGLTexture;
        if ((options === null || options === void 0 ? void 0 : options.channels) !== void 0)
          this.channels = options === null || options === void 0 ? void 0 : options.channels;
        if (!(effects instanceof EffectDictionary)) {
          effects = new EffectDictionary({ default: effects });
        }
        if (this.textureMode) {
          if (settings_1.settings.verbosity > 1) {
            console.log("we are in texture mode!");
          }
          for (const name in effects.effectMap) {
            const list = effects.effectMap[name];
            list.unshift(loop([scenesampleexpr_1.input()]).target(-1));
          }
        }
        this.source = source;
        this.gl = gl;
        this.options = options;
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        const vertexBuffer = this.gl.createBuffer();
        if (vertexBuffer === null) {
          throw new Error("problem creating vertex buffer");
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);
        const vertexArray = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        const triangles = new Float32Array(vertexArray);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, triangles, this.gl.STATIC_DRAW);
        this.vertexBuffer = vertexBuffer;
        const vShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (vShader === null) {
          throw new Error("problem creating the vertex shader");
        }
        this.vShader = vShader;
        this.gl.shaderSource(vShader, V_SOURCE);
        this.gl.compileShader(vShader);
        this.tex = {
          // make the front texture the source if we're given a texture instead of
          // an image
          back: {
            name: "orig_back",
            tex: source instanceof WebGLTexture ? source : makeTexture(this.gl, this.options)
          },
          front: { name: "orig_front", tex: makeTexture(this.gl, this.options) },
          scene: void 0,
          bufTextures: []
        };
        const framebuffer = gl.createFramebuffer();
        if (framebuffer === null) {
          throw new Error("problem creating the framebuffer");
        }
        this.framebuffer = framebuffer;
        const { programMap, needs } = effects.toProgramMap(this.gl, this.vShader, this.uniformLocs, this.fShaders);
        this.programMap = programMap;
        if (needs.sceneBuffer || this.textureMode) {
          this.tex.scene = {
            name: "scene",
            tex: makeTexture(this.gl, this.options)
          };
        }
        if (programMap["default"] === void 0) {
          throw new Error("no default program");
        }
        this.programLoop = programMap["default"];
        const channelsNeeded = Math.max(...needs.extraBuffers) + 1;
        const channelsSupplied = this.channels.length;
        if (channelsNeeded > channelsSupplied) {
          throw new Error("not enough channels supplied for this effect");
        }
        for (let i = 0; i < this.channels.length; i++) {
          const texOrImage = this.channels[i];
          if (!(texOrImage instanceof WebGLTexture)) {
            const texture = makeTexture(this.gl, this.options);
            this.tex.bufTextures.push({ name: "tex_channel_" + i, tex: texture });
          } else {
            this.tex.bufTextures.push({
              name: "img_channel_" + i,
              tex: texOrImage
            });
          }
        }
        if (settings_1.settings.verbosity > 0) {
          console.log(effects);
          console.log(this.programMap);
        }
      }
      /**
       * use the source and channels to draw effect to target context; mouse
       * position (as with all positions) are stored from the bottom left corner as
       * this is how texture data is stored
       * @param timeVal number to set the time uniform to (supply this if you plan to
       * use [[time]])
       * @param mouseX the x position of the mouse (supply this if you plan to use
       * [[mouse]] or [[nmouse]])
       * @param mouseY the y position of the mouse (supply this if you plan to use
       * [[mouse]] or [[nmouse]])
       */
      draw(timeVal = 0, mouseX = 0, mouseY = 0) {
        this.gl.activeTexture(this.gl.TEXTURE0 + settings_1.settings.offset);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.back.tex);
        sendTexture(this.gl, this.source);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        if (this.programLoop.getTotalNeeds().sceneBuffer && this.tex.scene !== void 0) {
          this.gl.activeTexture(this.gl.TEXTURE1 + settings_1.settings.offset);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.scene.tex);
          sendTexture(this.gl, this.source);
          this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        }
        let counter = 0;
        for (const b of this.channels) {
          this.gl.activeTexture(this.gl.TEXTURE2 + counter + settings_1.settings.offset);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.bufTextures[counter].tex);
          sendTexture(this.gl, b);
          this.gl.bindTexture(this.gl.TEXTURE_2D, null);
          counter++;
        }
        this.programLoop.run(this.gl, this.tex, this.framebuffer, this.uniformLocs, this.programLoop.last, { timeVal, mouseX, mouseY });
      }
      /**
       * delete all resources created by construction of this [[Merger]]; use right before
       * intentionally losing a reference to this merger object. this is useful if you want
       * to construct another [[Merger]] to use new effects
       */
      delete() {
        for (let i = 0; i < 2 + this.tex.bufTextures.length; i++) {
          this.gl.activeTexture(this.gl.TEXTURE0 + i + settings_1.settings.offset);
          this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.programLoop.delete(this.gl);
        this.gl.deleteTexture(this.tex.front.tex);
        this.gl.deleteTexture(this.tex.back.tex);
        for (const c of this.tex.bufTextures) {
          this.gl.deleteTexture(c.tex);
        }
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteFramebuffer(this.framebuffer);
        this.gl.deleteShader(this.vShader);
        for (const f of this.fShaders) {
          this.gl.deleteShader(f);
        }
      }
      /**
       * changes the current program loop
       * @param str key in the program map
       */
      changeProgram(str) {
        if (this.programMap[str] === void 0) {
          throw new Error(`program "${str}" doesn't exist on this merger`);
        }
        this.programLoop = this.programMap[str];
      }
    };
    exports.Merger = Merger;
    function makeTexture(gl, options) {
      const texture = gl.createTexture();
      if (texture === null) {
        throw new Error("problem creating texture");
      }
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      const filterMode = (f) => f === void 0 || f === "linear" ? gl.LINEAR : gl.NEAREST;
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.minFilterMode));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.maxFilterMode));
      if ((options === null || options === void 0 ? void 0 : options.edgeMode) !== "wrap") {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }
      return texture;
    }
    exports.makeTexture = makeTexture;
    function sendTexture(gl, src) {
      if (src instanceof WebGLTexture || src === null)
        return;
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
    }
    exports.sendTexture = sendTexture;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprtypes.js
var require_exprtypes = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprtypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/blurexpr.js
var require_blurexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/blurexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gauss = exports.BlurExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    function genBlurSource(direction, taps) {
      return {
        sections: [`gauss${taps}(`, ")"],
        values: [direction]
      };
    }
    function tapsToFuncSource(taps) {
      switch (taps) {
        case 5:
          return glslfunctions_1.glslFuncs.gauss5;
        case 9:
          return glslfunctions_1.glslFuncs.gauss9;
        case 13:
          return glslfunctions_1.glslFuncs.gauss13;
      }
    }
    var BlurExpr = class extends expr_1.ExprVec4 {
      constructor(direction, taps = 5, samplerNum) {
        if (![5, 9, 13].includes(taps)) {
          throw new Error("taps for gauss blur can only be 5, 9 or 13");
        }
        super(genBlurSource(direction, taps), ["uDirection"]);
        this.direction = direction;
        this.externalFuncs = [tapsToFuncSource(taps)];
        this.brandExprWithChannel(0, samplerNum);
      }
      /** set the blur direction (keep magnitude no greater than 1 for best effect) */
      setDirection(direction) {
        this.setUniform("uDirection" + this.id, direction);
        this.direction = direction;
      }
    };
    exports.BlurExpr = BlurExpr;
    function gauss(direction, taps = 5, samplerNum) {
      return new BlurExpr(direction, taps, samplerNum);
    }
    exports.gauss = gauss;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/vecexprs.js
var require_vecexprs = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/vecexprs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pvec4 = exports.pvec3 = exports.pvec2 = exports.vec4 = exports.vec3 = exports.vec2 = void 0;
    var expr_1 = require_expr();
    function vecSourceList(...components) {
      const sections = ["vec" + components.length + "("];
      for (let i = 0; i < components.length - 1; i++) {
        sections.push(", ");
      }
      const defaultNames = [];
      for (let i = 0; i < components.length; i++) {
        defaultNames.push("uComp" + i);
      }
      sections.push(")");
      return [{ sections, values: components }, defaultNames];
    }
    function vec2(comp1, comp2) {
      return new expr_1.BasicVec2(...vecSourceList(...[comp1, comp2].map((c) => expr_1.wrapInValue(c))));
    }
    exports.vec2 = vec2;
    function vec3(comp1, comp2, comp3) {
      return new expr_1.BasicVec3(...vecSourceList(...[comp1, comp2, comp3].map((c) => expr_1.wrapInValue(c))));
    }
    exports.vec3 = vec3;
    function vec4(comp1, comp2, comp3, comp4) {
      return new expr_1.BasicVec4(...vecSourceList(...[comp1, comp2, comp3, comp4].map((c) => expr_1.wrapInValue(c))));
    }
    exports.vec4 = vec4;
    function pvec2(comp1, comp2) {
      return new expr_1.PrimitiveVec2([comp1, comp2]);
    }
    exports.pvec2 = pvec2;
    function pvec3(comp1, comp2, comp3) {
      return new expr_1.PrimitiveVec3([comp1, comp2, comp3]);
    }
    exports.pvec3 = pvec3;
    function pvec4(comp1, comp2, comp3, comp4) {
      return new expr_1.PrimitiveVec4([comp1, comp2, comp3, comp4]);
    }
    exports.pvec4 = pvec4;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/powerblur.js
var require_powerblur = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/powerblur.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pblur = exports.PowerBlurLoop = void 0;
    var mergepass_1 = require_mergepass();
    var blurexpr_1 = require_blurexpr();
    var vecexprs_1 = require_vecexprs();
    var expr_1 = require_expr();
    var baseLog = (x, y) => Math.log(y) / Math.log(x);
    var PowerBlurLoop = class extends mergepass_1.EffectLoop {
      constructor(size) {
        const side = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(size, 0)));
        const up = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(0, size)));
        const reps = Math.ceil(baseLog(2, size));
        super([side, up], {
          num: reps + 1
        });
        this.size = size;
        this.loopInfo.func = (i) => {
          const distance = this.size / Math.pow(2, i);
          up.setDirection(vecexprs_1.pvec2(0, distance));
          side.setDirection(vecexprs_1.pvec2(distance, 0));
        };
      }
      /** sets the size of the radius */
      setSize(size) {
        this.size = size;
        this.loopInfo.num = Math.ceil(baseLog(2, size));
      }
    };
    exports.PowerBlurLoop = PowerBlurLoop;
    function pblur(size) {
      return new PowerBlurLoop(size);
    }
    exports.pblur = pblur;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/blur2dloop.js
var require_blur2dloop = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/blur2dloop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blur2d = exports.Blur2dLoop = void 0;
    var mergepass_1 = require_mergepass();
    var blurexpr_1 = require_blurexpr();
    var expr_1 = require_expr();
    var vecexprs_1 = require_vecexprs();
    var Blur2dLoop = class extends mergepass_1.EffectLoop {
      constructor(horizontal = expr_1.float(expr_1.mut(1)), vertical = expr_1.float(expr_1.mut(1)), reps = 2, taps, samplerNum) {
        const side = blurexpr_1.gauss(vecexprs_1.vec2(horizontal, 0), taps, samplerNum);
        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, vertical), taps, samplerNum);
        super([side, up], { num: reps });
        this.horizontal = horizontal;
        this.vertical = vertical;
      }
      /**
       * set the horizontal stretch of the blur effect (no greater than 1 for best
       * effect)
       */
      setHorizontal(num) {
        if (!(this.horizontal instanceof expr_1.BasicFloat))
          throw new Error("horizontal expression not basic float");
        this.horizontal.setVal(num);
      }
      /**
       * set the vertical stretch of the blur effect (no greater than 1 for best
       * effect)
       */
      setVertical(num) {
        if (!(this.vertical instanceof expr_1.BasicFloat))
          throw new Error("vertical expression not basic float");
        this.vertical.setVal(num);
      }
    };
    exports.Blur2dLoop = Blur2dLoop;
    function blur2d(horizontalExpr, verticalExpr, reps, taps, samplerNum) {
      return new Blur2dLoop(expr_1.wrapInValue(horizontalExpr), expr_1.wrapInValue(verticalExpr), reps, taps, samplerNum);
    }
    exports.blur2d = blur2d;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/lenexpr.js
var require_lenexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/lenexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.len = exports.LenExpr = void 0;
    var expr_1 = require_expr();
    var LenExpr = class extends expr_1.ExprFloat {
      constructor(vec) {
        super(expr_1.tag`length(${vec})`, ["uVec"]);
        this.vec = vec;
      }
      setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
      }
    };
    exports.LenExpr = LenExpr;
    function len(vec) {
      return new LenExpr(vec);
    }
    exports.len = len;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/normexpr.js
var require_normexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/normexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.norm = exports.NormExpr = void 0;
    var expr_1 = require_expr();
    var NormExpr = class extends expr_1.Operator {
      constructor(vec) {
        super(vec, expr_1.tag`normalize(${vec})`, ["uVec"]);
        this.vec = vec;
      }
      /** sets the vec to normalize */
      setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
      }
    };
    exports.NormExpr = NormExpr;
    function norm(vec) {
      return new NormExpr(vec);
    }
    exports.norm = norm;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/fragcoordexpr.js
var require_fragcoordexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/fragcoordexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pixel = exports.FragCoordExpr = void 0;
    var expr_1 = require_expr();
    var FragCoordExpr = class extends expr_1.ExprVec2 {
      constructor() {
        super(expr_1.tag`gl_FragCoord.xy`, []);
      }
    };
    exports.FragCoordExpr = FragCoordExpr;
    function pixel() {
      return new FragCoordExpr();
    }
    exports.pixel = pixel;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/normcenterfragcoordexpr.js
var require_normcenterfragcoordexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/normcenterfragcoordexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.center = exports.NormCenterFragCoordExpr = void 0;
    var expr_1 = require_expr();
    var NormCenterFragCoordExpr = class extends expr_1.ExprVec2 {
      constructor() {
        super(expr_1.tag`(gl_FragCoord.xy / uResolution - 0.5)`, []);
      }
    };
    exports.NormCenterFragCoordExpr = NormCenterFragCoordExpr;
    function center() {
      return new NormCenterFragCoordExpr();
    }
    exports.center = center;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/brightnessexpr.js
var require_brightnessexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/brightnessexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.brightness = exports.Brightness = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var Brightness = class extends expr_1.ExprVec4 {
      constructor(brightness2, col = fragcolorexpr_1.fcolor()) {
        super(expr_1.tag`brightness(${brightness2}, ${col})`, ["uBrightness", "uColor"]);
        this.brightness = brightness2;
        this.externalFuncs = [glslfunctions_1.glslFuncs.brightness];
      }
      /** set the brightness (should probably be between -1 and 1) */
      setBrightness(brightness2) {
        this.setUniform("uBrightness" + this.id, brightness2);
        this.brightness = expr_1.wrapInValue(brightness2);
      }
    };
    exports.Brightness = Brightness;
    function brightness(val, col) {
      return new Brightness(expr_1.wrapInValue(val), col);
    }
    exports.brightness = brightness;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/contrastexpr.js
var require_contrastexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/contrastexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contrast = exports.ContrastExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var ContrastExpr = class extends expr_1.ExprVec4 {
      constructor(contrast2, col = fragcolorexpr_1.fcolor()) {
        super(expr_1.tag`contrast(${contrast2}, ${col})`, ["uVal", "uCol"]);
        this.contrast = contrast2;
        this.externalFuncs = [glslfunctions_1.glslFuncs.contrast];
      }
      /** sets the contrast */
      setContrast(contrast2) {
        this.setUniform("uContrast" + this.id, contrast2);
        this.contrast = expr_1.wrapInValue(contrast2);
      }
    };
    exports.ContrastExpr = ContrastExpr;
    function contrast(val, col) {
      return new ContrastExpr(expr_1.wrapInValue(val), col);
    }
    exports.contrast = contrast;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/grainexpr.js
var require_grainexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/grainexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.grain = exports.GrainExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var GrainExpr = class extends expr_1.ExprVec4 {
      constructor(grain2) {
        super(expr_1.tag`vec4((1.0 - ${grain2} * random(gl_FragCoord.xy)) * gl_FragColor.rgb, gl_FragColor.a);`, ["uGrain"]);
        this.grain = grain2;
        this.externalFuncs = [glslfunctions_1.glslFuncs.random];
        this.needs.centerSample = true;
      }
      /** sets the grain level  */
      setGrain(grain2) {
        this.setUniform("uGrain" + this.id, grain2);
        this.grain = expr_1.wrapInValue(grain2);
      }
    };
    exports.GrainExpr = GrainExpr;
    function grain(val) {
      return new GrainExpr(expr_1.wrapInValue(val));
    }
    exports.grain = grain;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/changecompexpr.js
var require_changecompexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/changecompexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.changecomp = exports.ChangeCompExpr = void 0;
    var expr_1 = require_expr();
    var getcompexpr_1 = require_getcompexpr();
    function getChangeFunc(typ, id, setter, comps, op = "") {
      return `${typ} changecomp_${id}(${typ} col, ${setter.typeString()} setter) {
  col.${comps} ${op}= setter;
  return col;
}`;
    }
    function checkChangeComponents(comps, setter, vec) {
      if (comps.length !== getcompexpr_1.typeStringToLength(setter.typeString())) {
        throw new Error("components length must be equal to the target float/vec");
      }
      if (duplicateComponents(comps)) {
        throw new Error("duplicate components not allowed on left side");
      }
      getcompexpr_1.checkLegalComponents(comps, vec);
    }
    function duplicateComponents(comps) {
      return new Set(comps.split("")).size !== comps.length;
    }
    var ChangeCompExpr = class extends expr_1.Operator {
      constructor(vec, setter, comps, op) {
        checkChangeComponents(comps, setter, vec);
        const operation = op === "+" ? "plus" : op === "-" ? "minus" : op === "*" ? "mult" : op === "/" ? "div" : "assign";
        const suffix = `${vec.typeString()}_${setter.typeString()}_${comps}_${operation}`;
        super(vec, { sections: [`changecomp_${suffix}(`, ", ", ")"], values: [vec, setter] }, ["uOriginal", "uNew"]);
        this.originalVec = vec;
        this.newVal = setter;
        this.externalFuncs = [
          getChangeFunc(vec.typeString(), suffix, setter, comps, op)
        ];
      }
      /** set the original vector */
      setOriginal(originalVec) {
        this.setUniform("uOriginal" + this.id, originalVec);
        this.originalVec = originalVec;
      }
      /** set the neww vector */
      setNew(newVal) {
        this.setUniform("uNew" + this.id, newVal);
        this.newVal = expr_1.wrapInValue(newVal);
      }
    };
    exports.ChangeCompExpr = ChangeCompExpr;
    function changecomp(vec, setter, comps, op) {
      return new ChangeCompExpr(vec, expr_1.wrapInValue(setter), comps, op);
    }
    exports.changecomp = changecomp;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/rgbtohsvexpr.js
var require_rgbtohsvexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/rgbtohsvexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rgb2hsv = exports.RGBToHSVExpr = void 0;
    var expr_1 = require_expr();
    var glslfunctions_1 = require_glslfunctions();
    var RGBToHSVExpr = class extends expr_1.ExprVec4 {
      constructor(color) {
        super(expr_1.tag`rgb2hsv(${color})`, ["uRGBCol"]);
        this.color = color;
        this.externalFuncs = [glslfunctions_1.glslFuncs.rgb2hsv];
      }
      /** sets the color to convert */
      setColor(color) {
        this.setUniform("uRGBCol", color);
        this.color = color;
      }
    };
    exports.RGBToHSVExpr = RGBToHSVExpr;
    function rgb2hsv(col) {
      return new RGBToHSVExpr(col);
    }
    exports.rgb2hsv = rgb2hsv;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/hsvtorgbexpr.js
var require_hsvtorgbexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/hsvtorgbexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hsv2rgb = exports.HSVToRGBExpr = void 0;
    var expr_1 = require_expr();
    var glslfunctions_1 = require_glslfunctions();
    var HSVToRGBExpr = class extends expr_1.ExprVec4 {
      constructor(color) {
        super(expr_1.tag`hsv2rgb(${color})`, ["uHSVCol"]);
        this.color = color;
        this.externalFuncs = [glslfunctions_1.glslFuncs.hsv2rgb];
      }
      /** sets the color to convert */
      setColor(color) {
        this.setUniform("uHSVCol", color);
        this.color = color;
      }
    };
    exports.HSVToRGBExpr = HSVToRGBExpr;
    function hsv2rgb(col) {
      return new HSVToRGBExpr(col);
    }
    exports.hsv2rgb = hsv2rgb;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/timeexpr.js
var require_timeexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/timeexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.time = exports.TimeExpr = void 0;
    var expr_1 = require_expr();
    var TimeExpr = class extends expr_1.ExprFloat {
      constructor() {
        super(expr_1.tag`uTime`, []);
        this.needs.timeUniform = true;
      }
    };
    exports.TimeExpr = TimeExpr;
    function time() {
      return new TimeExpr();
    }
    exports.time = time;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/arity1.js
var require_arity1 = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/arity1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.a1 = exports.Arity1HomogenousExpr = void 0;
    var expr_1 = require_expr();
    function genArity1SourceList(name, val) {
      return {
        sections: [name + "(", ")"],
        values: [val]
      };
    }
    var Arity1HomogenousExpr = class extends expr_1.Operator {
      constructor(val, operation) {
        super(val, genArity1SourceList(operation, val), ["uVal"]);
        this.val = val;
      }
      /** set the value being passed into the arity 1 homogenous function */
      setVal(val) {
        this.setUniform("uVal" + this.id, val);
        this.val = expr_1.wrapInValue(val);
      }
    };
    exports.Arity1HomogenousExpr = Arity1HomogenousExpr;
    function a1(name, val) {
      return new Arity1HomogenousExpr(expr_1.wrapInValue(val), name);
    }
    exports.a1 = a1;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/arity2.js
var require_arity2 = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/arity2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.a2 = exports.Arity2HomogenousExpr = void 0;
    var expr_1 = require_expr();
    function genArity1SourceList(name, val1, val2) {
      return {
        sections: [name + "(", ",", ")"],
        values: [val1, val2]
      };
    }
    var Arity2HomogenousExpr = class extends expr_1.Operator {
      constructor(name, val1, val2) {
        super(val1, genArity1SourceList(name, val1, val2), ["uVal1", "uVal2"]);
        this.val1 = val1;
        this.val2 = val2;
      }
      /** set the first value being passed into the arity 2 homogenous function */
      setFirstVal(val1) {
        this.setUniform("uVal1" + this.id, val1);
        this.val1 = expr_1.wrapInValue(val1);
      }
      /** set the second value being passed into the arity 2 homogenous function */
      setSecondVal(val2) {
        this.setUniform("uVal2" + this.id, val2);
        this.val2 = expr_1.wrapInValue(val2);
      }
    };
    exports.Arity2HomogenousExpr = Arity2HomogenousExpr;
    function a2(name, val1, val2) {
      return new Arity2HomogenousExpr(name, expr_1.wrapInValue(val1), expr_1.wrapInValue(val2));
    }
    exports.a2 = a2;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/fxaaexpr.js
var require_fxaaexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/fxaaexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fxaa = void 0;
    var expr_1 = require_expr();
    var glslfunctions_1 = require_glslfunctions();
    var FXAAExpr = class extends expr_1.ExprVec4 {
      constructor() {
        super(expr_1.tag`fxaa()`, []);
        this.externalFuncs = [glslfunctions_1.glslFuncs.fxaa];
        this.needs.neighborSample = true;
      }
    };
    function fxaa() {
      return new FXAAExpr();
    }
    exports.fxaa = fxaa;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/channelsampleexpr.js
var require_channelsampleexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/channelsampleexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.channel = exports.ChannelSampleExpr = void 0;
    var codebuilder_1 = require_codebuilder();
    var expr_1 = require_expr();
    var normfragcoordexpr_1 = require_normfragcoordexpr();
    var glslfunctions_1 = require_glslfunctions();
    function genChannelSampleSource(buf, coord) {
      return {
        sections: ["channel(", `, ${codebuilder_1.channelSamplerName(buf)})`],
        values: [coord]
      };
    }
    var ChannelSampleExpr = class extends expr_1.ExprVec4 {
      constructor(buf, coord = normfragcoordexpr_1.pos()) {
        super(genChannelSampleSource(buf, coord), ["uVec"]);
        this.coord = coord;
        this.externalFuncs = [glslfunctions_1.glslFuncs.channel];
        if (buf !== -1)
          this.needs.extraBuffers = /* @__PURE__ */ new Set([buf]);
        else
          this.needs.neighborSample = true;
      }
      setCoord(coord) {
        this.setUniform("uVec", coord);
        this.coord = coord;
      }
    };
    exports.ChannelSampleExpr = ChannelSampleExpr;
    function channel(channel2, vec) {
      return new ChannelSampleExpr(channel2, vec);
    }
    exports.channel = channel;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/gaussianexpr.js
var require_gaussianexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/gaussianexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gaussian = exports.GaussianExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var GaussianExpr = class extends expr_1.ExprFloat {
      constructor(x, a, b) {
        super(expr_1.tag`gaussian(${x}, ${a}, ${b})`, ["uFloatX", "uFloatA", "uFloatB"]);
        this.x = x;
        this.a = a;
        this.b = b;
        this.externalFuncs = [glslfunctions_1.glslFuncs.gaussian];
      }
      setX(x) {
        this.setUniform("uFloatX" + this.id, x);
        this.x = expr_1.wrapInValue(x);
      }
      setA(a) {
        this.setUniform("uFloatA" + this.id, a);
        this.a = expr_1.wrapInValue(a);
      }
      setB(b) {
        this.setUniform("uFloatB" + this.id, b);
        this.b = expr_1.wrapInValue(b);
      }
    };
    exports.GaussianExpr = GaussianExpr;
    function gaussian(x, a = 0, b = 1) {
      return new GaussianExpr(expr_1.wrapInValue(x), expr_1.wrapInValue(a), expr_1.wrapInValue(b));
    }
    exports.gaussian = gaussian;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/dofloop.js
var require_dofloop = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/dofloop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dof = exports.DoFLoop = void 0;
    var mergepass_1 = require_mergepass();
    var arity2_1 = require_arity2();
    var blurexpr_1 = require_blurexpr();
    var channelsampleexpr_1 = require_channelsampleexpr();
    var expr_1 = require_expr();
    var gaussianexpr_1 = require_gaussianexpr();
    var getcompexpr_1 = require_getcompexpr();
    var opexpr_1 = require_opexpr();
    var vecexprs_1 = require_vecexprs();
    var DoFLoop = class extends mergepass_1.EffectLoop {
      constructor(depth = expr_1.mut(expr_1.pfloat(0.3)), rad = expr_1.mut(expr_1.pfloat(0.01)), depthInfo = getcompexpr_1.getcomp(channelsampleexpr_1.channel(0), "r"), reps = 2, taps = 13) {
        let guassianExpr = gaussianexpr_1.gaussian(depthInfo, depth, rad);
        const side = blurexpr_1.gauss(vecexprs_1.vec2(arity2_1.a2("pow", opexpr_1.op(1, "-", guassianExpr), 4), 0), taps);
        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, arity2_1.a2("pow", opexpr_1.op(1, "-", guassianExpr), 4)), taps);
        super([side, up], { num: reps });
        this.gaussian = guassianExpr;
      }
      setDepth(depth) {
        this.gaussian.setA(depth);
      }
      setRadius(radius) {
        this.gaussian.setB(radius);
      }
    };
    exports.DoFLoop = DoFLoop;
    function dof(depth, rad, depthInfo, reps) {
      return new DoFLoop(expr_1.wrapInValue(depth), expr_1.wrapInValue(rad), expr_1.wrapInValue(depthInfo), reps);
    }
    exports.dof = dof;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/truedepthexpr.js
var require_truedepthexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/truedepthexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.truedepth = exports.TrueDepthExpr = void 0;
    var expr_1 = require_expr();
    var glslfunctions_1 = require_glslfunctions();
    var TrueDepthExpr = class extends expr_1.ExprFloat {
      constructor(depth) {
        super(expr_1.tag`truedepth(${depth})`, ["uDist"]);
        this.depth = depth;
        this.externalFuncs = [glslfunctions_1.glslFuncs.truedepth];
      }
      /** sets the distance to convert to the true depth */
      setDist(depth) {
        this.setUniform("uDist", depth);
        this.depth = expr_1.wrapInValue(depth);
      }
    };
    exports.TrueDepthExpr = TrueDepthExpr;
    function truedepth(depth) {
      return new TrueDepthExpr(expr_1.wrapInValue(depth));
    }
    exports.truedepth = truedepth;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/godraysexpr.js
var require_godraysexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/godraysexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.godrays = exports.GodRaysExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var vecexprs_1 = require_vecexprs();
    var DEFAULT_SAMPLES = 100;
    var GodRaysExpr = class extends expr_1.ExprVec4 {
      // sane godray defaults from https://github.com/Erkaman/glsl-godrays/blob/master/example/index.js
      constructor(col = fragcolorexpr_1.fcolor(), exposure = expr_1.mut(1), decay = expr_1.mut(1), density = expr_1.mut(1), weight = expr_1.mut(0.01), lightPos = expr_1.mut(vecexprs_1.pvec2(0.5, 0.5)), samplerNum = 0, numSamples = DEFAULT_SAMPLES, convertDepth) {
        const sourceLists = expr_1.tag`${col}, ${exposure}, ${decay}, ${density}, ${weight}, ${lightPos}, ${convertDepth !== void 0 ? convertDepth.threshold : expr_1.float(0)}, ${convertDepth !== void 0 ? convertDepth.newColor : vecexprs_1.vec4(0, 0, 0, 0)})`;
        const customName = `godrays${convertDepth !== void 0 ? "_depth" : ""}${numSamples !== 100 ? "_s" + numSamples : ""}(`;
        sourceLists.sections[0] = customName;
        super(sourceLists, [
          "uCol",
          "uExposure",
          "uDecay",
          "uDensity",
          "uWeight",
          "uLightPos",
          "uThreshold",
          "uNewColor"
        ]);
        this.col = col;
        this.exposure = exposure;
        this.decay = decay;
        this.density = density;
        this.weight = weight;
        this.lightPos = lightPos;
        this.threshold = convertDepth === null || convertDepth === void 0 ? void 0 : convertDepth.threshold;
        this.newColor = convertDepth === null || convertDepth === void 0 ? void 0 : convertDepth.newColor;
        this.funcIndex = ~~(convertDepth !== void 0);
        let customGodRayFunc = glslfunctions_1.glslFuncs.godrays.split("godrays(").join(customName).replace(`NUM_SAMPLES = ${DEFAULT_SAMPLES}`, "NUM_SAMPLES = " + numSamples);
        if (convertDepth !== void 0) {
          customGodRayFunc = customGodRayFunc.replace(/\/\/uncomment\s/g, "");
          this.externalFuncs.push(glslfunctions_1.glslFuncs.depth2occlusion);
        }
        this.externalFuncs.push(customGodRayFunc);
        this.brandExprWithChannel(this.funcIndex, samplerNum);
      }
      /** sets the light color */
      setColor(color) {
        this.setUniform("uCol" + this.id, color);
        this.col = color;
      }
      /** sets the exposure */
      setExposure(exposure) {
        this.setUniform("uExposure" + this.id, exposure);
        this.exposure = expr_1.wrapInValue(exposure);
      }
      /** sets the decay */
      setDecay(decay) {
        this.setUniform("uDecay" + this.id, decay);
        this.decay = expr_1.wrapInValue(decay);
      }
      /** sets the density */
      setDensity(density) {
        this.setUniform("uDensity" + this.id, density);
        this.density = expr_1.wrapInValue(density);
      }
      /** sets the weight */
      setWeight(weight) {
        this.setUniform("uWeight" + this.id, weight);
        this.weight = expr_1.wrapInValue(weight);
      }
      /** sets the light position */
      setLightPos(lightPos) {
        this.setUniform("uLightPos" + this.id, lightPos);
        this.lightPos = lightPos;
      }
      // these only matter when you're using a depth buffer and not an occlusion
      // buffer (although right now, you'll still be able to set them)
      setThreshold(threshold) {
        this.setUniform("uThreshold" + this.id, threshold);
        this.threshold = expr_1.wrapInValue(threshold);
      }
      setNewColor(newColor) {
        this.setUniform("uNewColor" + this.id, newColor);
        this.newColor = newColor;
      }
    };
    exports.GodRaysExpr = GodRaysExpr;
    function godrays(options = {}) {
      return new GodRaysExpr(options.color, expr_1.wrapInValue(options.exposure), expr_1.wrapInValue(options.decay), expr_1.wrapInValue(options.density), expr_1.wrapInValue(options.weight), options.lightPos, options.samplerNum, options.numSamples, options.convertDepth === void 0 ? void 0 : {
        threshold: expr_1.wrapInValue(options.convertDepth.threshold),
        newColor: options.convertDepth.newColor
      });
    }
    exports.godrays = godrays;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/depthtoocclusionexpr.js
var require_depthtoocclusionexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/depthtoocclusionexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.depth2occlusion = exports.DepthToOcclusionExpr = void 0;
    var channelsampleexpr_1 = require_channelsampleexpr();
    var expr_1 = require_expr();
    var vecexprs_1 = require_vecexprs();
    var DepthToOcclusionExpr = class extends expr_1.ExprVec4 {
      constructor(depthCol = channelsampleexpr_1.channel(0), newCol = expr_1.mut(vecexprs_1.pvec4(1, 1, 1, 1)), threshold = expr_1.mut(expr_1.pfloat(0.01))) {
        super(expr_1.tag`depth2occlusion(${depthCol}, ${newCol}, ${threshold})`, [
          "uDepth",
          "uNewCol",
          "uThreshold"
        ]);
        this.depthCol = depthCol;
        this.newCol = newCol;
        this.threshold = threshold;
      }
      setDepthColor(depthCol) {
        this.setUniform("uDepth" + this.id, depthCol);
        this.depthCol = depthCol;
      }
      setNewColor(newCol) {
        this.setUniform("uNewCol" + this.id, newCol);
        this.newCol = newCol;
      }
      setThreshold(threshold) {
        this.setUniform("uThreshold" + this.id, threshold);
        this.threshold = expr_1.wrapInValue(threshold);
      }
    };
    exports.DepthToOcclusionExpr = DepthToOcclusionExpr;
    function depth2occlusion(depthCol, newCol, threshold) {
      return new DepthToOcclusionExpr(depthCol, newCol, expr_1.wrapInValue(threshold));
    }
    exports.depth2occlusion = depth2occlusion;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/resolutionexpr.js
var require_resolutionexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/resolutionexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolution = exports.ResolutionExpr = void 0;
    var expr_1 = require_expr();
    var ResolutionExpr = class extends expr_1.ExprVec2 {
      constructor() {
        super(expr_1.tag`uResolution`, []);
      }
    };
    exports.ResolutionExpr = ResolutionExpr;
    function resolution() {
      return new ResolutionExpr();
    }
    exports.resolution = resolution;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/mouseexpr.js
var require_mouseexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/mouseexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mouse = exports.MouseExpr = void 0;
    var expr_1 = require_expr();
    var MouseExpr = class extends expr_1.ExprVec2 {
      constructor() {
        super(expr_1.tag`uMouse`, []);
        this.needs.mouseUniform = true;
      }
    };
    exports.MouseExpr = MouseExpr;
    function mouse() {
      return new MouseExpr();
    }
    exports.mouse = mouse;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/rotateexpr.js
var require_rotateexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/rotateexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rotate = exports.RotateExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var RotateExpr = class extends expr_1.ExprVec2 {
      constructor(vec, angle) {
        super(expr_1.tag`rotate2d(${vec}, ${angle})`, ["uVec", "uAngle"]);
        this.vec = vec;
        this.angle = angle;
        this.externalFuncs = [glslfunctions_1.glslFuncs.rotate2d];
      }
      /** set the vector to rotate */
      setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
      }
      /** set the angle to rotate by */
      setAngle(angle) {
        this.setUniform("uAngle" + this.id, angle);
        this.angle = expr_1.wrapInValue(angle);
      }
    };
    exports.RotateExpr = RotateExpr;
    function rotate(vec, angle) {
      return new RotateExpr(vec, expr_1.wrapInValue(angle));
    }
    exports.rotate = rotate;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/translateexpr.js
var require_translateexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/translateexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.translate = exports.TranslateExpr = void 0;
    var expr_1 = require_expr();
    var TranslateExpr = class extends expr_1.ExprVec2 {
      constructor(vec, pos) {
        super(expr_1.tag`(${vec} + ${pos})`, ["uVec", "uPos"]);
        this.vec = vec;
        this.pos = pos;
      }
      /** sets the starting position */
      setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
      }
      /** sets how far the vector will be translated */
      setPos(pos) {
        this.setUniform("uPos" + this.id, pos);
        this.pos = pos;
      }
    };
    exports.TranslateExpr = TranslateExpr;
    function translate(vec, pos) {
      return new TranslateExpr(vec, pos);
    }
    exports.translate = translate;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/normmouseexpr.js
var require_normmouseexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/normmouseexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nmouse = exports.NormMouseExpr = void 0;
    var expr_1 = require_expr();
    var NormMouseExpr = class extends expr_1.ExprVec2 {
      constructor() {
        super(expr_1.tag`(uMouse / uResolution.xy)`, []);
        this.needs.mouseUniform = true;
      }
    };
    exports.NormMouseExpr = NormMouseExpr;
    function nmouse() {
      return new NormMouseExpr();
    }
    exports.nmouse = nmouse;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/perlinexpr.js
var require_perlinexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/perlinexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fractalize = exports.perlin = exports.PerlinExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var opexpr_1 = require_opexpr();
    var PerlinExpr = class extends expr_1.ExprFloat {
      // TODO include a default
      constructor(pos) {
        super(expr_1.tag`gradientnoise(${pos})`, ["uPos"]);
        this.pos = pos;
        this.externalFuncs = [glslfunctions_1.glslFuncs.random2, glslfunctions_1.glslFuncs.gradientnoise];
      }
      /** sets the position to calculate noise value of */
      setPos(pos) {
        this.setUniform("uPos", pos);
        this.pos = pos;
      }
    };
    exports.PerlinExpr = PerlinExpr;
    function perlin(pos) {
      return new PerlinExpr(pos);
    }
    exports.perlin = perlin;
    function fractalize(pos, octaves, func) {
      if (octaves < 0)
        throw new Error("octaves can't be < 0");
      const recurse = (pos2, size, level) => {
        if (level <= 0)
          return expr_1.pfloat(0);
        return opexpr_1.op(func(opexpr_1.op(pos2, "/", size * 2)), "+", recurse(pos2, size / 2, level - 1));
      };
      return recurse(pos, 0.5, octaves);
    }
    exports.fractalize = fractalize;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/simplexexpr.js
var require_simplexexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/simplexexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simplex = exports.SimplexNoise = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var SimplexNoise = class extends expr_1.ExprFloat {
      constructor(pos) {
        super(expr_1.tag`simplexnoise(${pos})`, ["uPos"]);
        this.pos = pos;
        this.externalFuncs = [glslfunctions_1.glslFuncs.simplexhelpers, glslfunctions_1.glslFuncs.simplexnoise];
      }
      setPos(pos) {
        this.setUniform("uPos", pos);
        this.pos = pos;
      }
    };
    exports.SimplexNoise = SimplexNoise;
    function simplex(pos) {
      return new SimplexNoise(pos);
    }
    exports.simplex = simplex;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/motionblurloop.js
var require_motionblurloop = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/motionblurloop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.motionblur = exports.MotionBlurLoop = void 0;
    var mergepass_1 = require_mergepass();
    var channelsampleexpr_1 = require_channelsampleexpr();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var opexpr_1 = require_opexpr();
    var MotionBlurLoop = class extends mergepass_1.EffectLoop {
      constructor(target = 0, persistence = expr_1.float(expr_1.mut(0.3))) {
        const col1 = opexpr_1.op(channelsampleexpr_1.channel(target), "*", persistence);
        const col2 = opexpr_1.op(fragcolorexpr_1.fcolor(), "*", opexpr_1.op(1, "-", persistence));
        const effects = [
          mergepass_1.loop([opexpr_1.op(col1, "+", col2)]).target(target),
          channelsampleexpr_1.channel(target)
        ];
        super(effects, { num: 1 });
        this.persistence = persistence;
      }
      /** set the persistence (keep between 0 and 1) */
      setPersistence(float) {
        if (!(this.persistence instanceof expr_1.BasicFloat))
          throw new Error("persistence expression not basic float");
        this.persistence.setVal(float);
      }
    };
    exports.MotionBlurLoop = MotionBlurLoop;
    function motionblur(target, persistence) {
      return new MotionBlurLoop(target, expr_1.wrapInValue(persistence));
    }
    exports.motionblur = motionblur;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/randomexpr.js
var require_randomexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/randomexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.random = exports.RandomExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var normfragcoordexpr_1 = require_normfragcoordexpr();
    var RandomExpr = class extends expr_1.ExprFloat {
      constructor(seed = normfragcoordexpr_1.pos()) {
        super(expr_1.tag`random(${seed})`, ["uSeed"]);
        this.seed = seed;
        this.externalFuncs = [glslfunctions_1.glslFuncs.random];
      }
      /** sets the seed (vary this over time to get a moving effect) */
      setSeed(seed) {
        this.setUniform("uSeed", seed);
        this.seed = seed;
      }
    };
    exports.RandomExpr = RandomExpr;
    function random(seed) {
      return new RandomExpr(seed);
    }
    exports.random = random;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/sobelexpr.js
var require_sobelexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/sobelexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sobel = exports.SobelExpr = void 0;
    var glslfunctions_1 = require_glslfunctions();
    var expr_1 = require_expr();
    var SobelExpr = class extends expr_1.ExprVec4 {
      constructor(samplerNum) {
        super(expr_1.tag`sobel()`, []);
        this.externalFuncs = [glslfunctions_1.glslFuncs.sobel];
        this.brandExprWithChannel(0, samplerNum);
      }
    };
    exports.SobelExpr = SobelExpr;
    function sobel(samplerNum) {
      return new SobelExpr(samplerNum);
    }
    exports.sobel = sobel;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/bloomloop.js
var require_bloomloop = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/bloomloop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bloom = exports.BloomLoop = void 0;
    var mergepass_1 = require_mergepass();
    var arity2_1 = require_arity2();
    var blurexpr_1 = require_blurexpr();
    var brightnessexpr_1 = require_brightnessexpr();
    var channelsampleexpr_1 = require_channelsampleexpr();
    var contrastexpr_1 = require_contrastexpr();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var opexpr_1 = require_opexpr();
    var vecexprs_1 = require_vecexprs();
    var BloomLoop = class extends mergepass_1.EffectLoop {
      constructor(threshold = expr_1.float(expr_1.mut(0.4)), horizontal = expr_1.float(expr_1.mut(1)), vertical = expr_1.float(expr_1.mut(1)), boost = expr_1.float(expr_1.mut(1.3)), samplerNum = 1, taps = 9, reps = 3) {
        const bright = expr_1.cfloat(expr_1.tag`((${channelsampleexpr_1.channel(samplerNum)}.r + ${channelsampleexpr_1.channel(samplerNum)}.g + ${channelsampleexpr_1.channel(samplerNum)}.b) / 3.)`);
        const step = arity2_1.a2("step", bright, threshold);
        const col = expr_1.cvec4(expr_1.tag`vec4(${channelsampleexpr_1.channel(samplerNum)}.rgb * (1. - ${step}), 1.)`);
        const list = [
          mergepass_1.loop([col]).target(samplerNum),
          mergepass_1.loop([
            blurexpr_1.gauss(vecexprs_1.vec2(horizontal, 0), taps),
            blurexpr_1.gauss(vecexprs_1.vec2(0, vertical), taps),
            brightnessexpr_1.brightness(0.1),
            contrastexpr_1.contrast(boost)
          ], reps).target(samplerNum),
          opexpr_1.op(fragcolorexpr_1.fcolor(), "+", channelsampleexpr_1.channel(samplerNum))
        ];
        super(list, { num: 1 });
        this.threshold = threshold;
        this.horizontal = horizontal;
        this.vertical = vertical;
        this.boost = boost;
      }
      /**
       * set the horizontal stretch of the blur effect (no greater than 1 for best
       * effect)
       */
      setHorizontal(num) {
        if (!(this.horizontal instanceof expr_1.BasicFloat))
          throw new Error("horizontal expression not basic float");
        this.horizontal.setVal(num);
      }
      /**
       * set the vertical stretch of the blur effect (no greater than 1 for best
       * effect)
       */
      setVertical(num) {
        if (!(this.vertical instanceof expr_1.BasicFloat))
          throw new Error("vertical expression not basic float");
        this.vertical.setVal(num);
      }
      /** set the treshold */
      setThreshold(num) {
        if (!(this.threshold instanceof expr_1.BasicFloat))
          throw new Error("threshold expression not basic float");
        this.threshold.setVal(num);
      }
      /** set the contrast boost */
      setBoost(num) {
        if (!(this.boost instanceof expr_1.BasicFloat))
          throw new Error("boost expression not basic float");
        this.boost.setVal(num);
      }
    };
    exports.BloomLoop = BloomLoop;
    function bloom(threshold, horizontal, vertical, boost, samplerNum, taps, reps) {
      return new BloomLoop(expr_1.wrapInValue(threshold), expr_1.wrapInValue(horizontal), expr_1.wrapInValue(vertical), expr_1.wrapInValue(boost), samplerNum, taps, reps);
    }
    exports.bloom = bloom;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/monochromeexpr.js
var require_monochromeexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/monochromeexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.monochrome = exports.MonochromeExpr = void 0;
    var expr_1 = require_expr();
    var glslfunctions_1 = require_glslfunctions();
    var MonochromeExpr = class extends expr_1.ExprVec4 {
      constructor(color) {
        super(expr_1.tag`monochrome(${color})`, ["uColor"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.monochrome];
        this.color = color;
      }
      /** sets the color */
      setColor(color) {
        this.setUniform("uColor", color);
        this.color = color;
      }
    };
    exports.MonochromeExpr = MonochromeExpr;
    function monochrome(col) {
      return new MonochromeExpr(col);
    }
    exports.monochrome = monochrome;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/invertexpr.js
var require_invertexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/invertexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.invert = exports.InvertExpr = void 0;
    var expr_1 = require_expr();
    var glslfunctions_1 = require_glslfunctions();
    var InvertExpr = class extends expr_1.ExprVec4 {
      constructor(color) {
        super(expr_1.tag`invert(${color})`, ["uColor"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.invert];
        this.color = color;
      }
      /** sets the color */
      setColor(color) {
        this.setUniform("uColor", color);
        this.color = color;
      }
    };
    exports.InvertExpr = InvertExpr;
    function invert(col) {
      return new InvertExpr(col);
    }
    exports.invert = invert;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/edgeexpr.js
var require_edgeexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/edgeexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edge = exports.EdgeExpr = void 0;
    var brightnessexpr_1 = require_brightnessexpr();
    var expr_1 = require_expr();
    var getcompexpr_1 = require_getcompexpr();
    var invertexpr_1 = require_invertexpr();
    var monochromeexpr_1 = require_monochromeexpr();
    var opexpr_1 = require_opexpr();
    var sobelexpr_1 = require_sobelexpr();
    var EdgeExpr = class extends expr_1.WrappedExpr {
      constructor(mult = expr_1.mut(-1), samplerNum) {
        const operator = opexpr_1.op(getcompexpr_1.getcomp(invertexpr_1.invert(monochromeexpr_1.monochrome(sobelexpr_1.sobel(samplerNum))), "r"), "*", mult);
        super(brightnessexpr_1.brightness(operator));
        this.mult = mult;
        this.operator = operator;
      }
      setMult(mult) {
        this.operator.setRight(mult);
        this.mult = expr_1.wrapInValue(mult);
      }
    };
    exports.EdgeExpr = EdgeExpr;
    function edge(style, samplerNum) {
      const mult = style === "dark" ? -1 : style === "light" ? 1 : style;
      return new EdgeExpr(expr_1.wrapInValue(mult), samplerNum);
    }
    exports.edge = edge;
  }
});

// node_modules/@bandaloo/merge-pass/dist/exprs/edgecolorexpr.js
var require_edgecolorexpr = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/exprs/edgecolorexpr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edgecolor = exports.EdgeColorExpr = void 0;
    var arity2_1 = require_arity2();
    var expr_1 = require_expr();
    var fragcolorexpr_1 = require_fragcolorexpr();
    var monochromeexpr_1 = require_monochromeexpr();
    var sobelexpr_1 = require_sobelexpr();
    var vecexprs_1 = require_vecexprs();
    var EdgeColorExpr = class extends expr_1.WrappedExpr {
      constructor(color, samplerNum, stepped = true) {
        const expr = stepped ? expr_1.cvec4(expr_1.tag`mix(${color}, ${fragcolorexpr_1.fcolor()}, ${monochromeexpr_1.monochrome(arity2_1.a2("step", vecexprs_1.vec4(0.5, 0.5, 0.5, 0), sobelexpr_1.sobel(samplerNum)))})`) : expr_1.cvec4(expr_1.tag`mix(${color}, ${fragcolorexpr_1.fcolor()}, ${monochromeexpr_1.monochrome(sobelexpr_1.sobel(samplerNum))})`);
        super(expr);
        this.color = color;
        this.expr = expr;
      }
      setColor(color) {
        this.expr.setUniform("uCustomName0" + this.expr.id, color);
        this.color = color;
      }
    };
    exports.EdgeColorExpr = EdgeColorExpr;
    function edgecolor(color, samplerNum, stepped) {
      return new EdgeColorExpr(color, samplerNum, stepped);
    }
    exports.edgecolor = edgecolor;
  }
});

// node_modules/@bandaloo/merge-pass/dist/index.js
var require_dist = __commonJS({
  "node_modules/@bandaloo/merge-pass/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_mergepass(), exports);
    __exportStar(require_exprtypes(), exports);
    __exportStar(require_glslfunctions(), exports);
    __exportStar(require_settings(), exports);
    __exportStar(require_blurexpr(), exports);
    __exportStar(require_fragcolorexpr(), exports);
    __exportStar(require_vecexprs(), exports);
    __exportStar(require_opexpr(), exports);
    __exportStar(require_powerblur(), exports);
    __exportStar(require_blur2dloop(), exports);
    __exportStar(require_lenexpr(), exports);
    __exportStar(require_normexpr(), exports);
    __exportStar(require_fragcoordexpr(), exports);
    __exportStar(require_normfragcoordexpr(), exports);
    __exportStar(require_normcenterfragcoordexpr(), exports);
    __exportStar(require_scenesampleexpr(), exports);
    __exportStar(require_brightnessexpr(), exports);
    __exportStar(require_contrastexpr(), exports);
    __exportStar(require_grainexpr(), exports);
    __exportStar(require_getcompexpr(), exports);
    __exportStar(require_changecompexpr(), exports);
    __exportStar(require_rgbtohsvexpr(), exports);
    __exportStar(require_hsvtorgbexpr(), exports);
    __exportStar(require_timeexpr(), exports);
    __exportStar(require_arity1(), exports);
    __exportStar(require_arity2(), exports);
    __exportStar(require_fxaaexpr(), exports);
    __exportStar(require_channelsampleexpr(), exports);
    __exportStar(require_dofloop(), exports);
    __exportStar(require_truedepthexpr(), exports);
    __exportStar(require_godraysexpr(), exports);
    __exportStar(require_depthtoocclusionexpr(), exports);
    __exportStar(require_resolutionexpr(), exports);
    __exportStar(require_mouseexpr(), exports);
    __exportStar(require_rotateexpr(), exports);
    __exportStar(require_translateexpr(), exports);
    __exportStar(require_normmouseexpr(), exports);
    __exportStar(require_perlinexpr(), exports);
    __exportStar(require_simplexexpr(), exports);
    __exportStar(require_motionblurloop(), exports);
    __exportStar(require_randomexpr(), exports);
    __exportStar(require_sobelexpr(), exports);
    __exportStar(require_bloomloop(), exports);
    __exportStar(require_monochromeexpr(), exports);
    __exportStar(require_invertexpr(), exports);
    __exportStar(require_edgeexpr(), exports);
    __exportStar(require_edgecolorexpr(), exports);
    __exportStar(require_ternaryexpr(), exports);
    __exportStar(require_regiondecorator(), exports);
    __exportStar(require_expr(), exports);
  }
});

export {
  __commonJS,
  require_dist
};
//# sourceMappingURL=chunk-QFKO4ZYM.js.map
